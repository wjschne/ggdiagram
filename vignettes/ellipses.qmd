---
title: "Ellipses"
knitr:
  opts_chunk: 
    collapse: true
    comment: '#>'
format: 
  html:
    toc: true
    html-math-method: katex
vignette: >
  %\VignetteIndexEntry{angles}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

```{r presetup, include = FALSE}
library(ggdiagram)
library(ggplot2)
library(dplyr)
library(ggtext)
library(ggarrow)
knitr::opts_chunk$set(
  collapse = TRUE,
  dev = "ragg_png",
  comment = "#>",
  fig.width = 7,
  fig.height = 7
)
my_font <- "Roboto Condensed"
# gdtools::register_gfont(family = my_font)
# gdtools::addGFontHtmlDependency(family = my_font)
update_geom_defaults("richtext",
                     list(family = my_font, 
                          size = .8 * 16 / ggplot2::.pt))

update_geom_defaults("arrow_segment", list(length_head = 1))
```

```{r setup}
library(ggdiagram)
library(ggplot2)
library(dplyr)
library(ggtext)
library(ggarrow)
my_font <- "Roboto Condensed"

```


## Base plot

To avoid repetitive code, we make a base plot:

```{r baseplot}
my_font <- "Roboto Condensed"
my_text_size <- 20
my_point_size <- 2.5
# my_colors <- viridis::viridis(2, begin = .25, end = .5)
my_colors <- c("#3B528B", "#21908C")
update_geom_defaults(geom = "richtext", 
                     new = list(family = my_font, 
                                size = .8 * my_text_size / ggplot2::.pt))

update_geom_defaults("point", list(size = my_point_size))


theme_set(
  theme_minimal(
    base_size = my_text_size, 
    base_family = my_font) +
    theme(axis.title.y = element_text(angle = 0, vjust = 0.5)))




bp <- ggplot() +
  coord_equal() +
  scale_x_continuous(labels = WJSmisc::signs_centered, limits = c(-4, 4)) +
  scale_y_continuous(labels = signs::signs, limits = c(-4, 4)) +
  theme_minimal(base_size = 16) +
  theme(
    axis.title.x =  element_text(face = "italic"),
    axis.title.y = element_text(
      face = "italic",
      angle = 0,
      hjust = .5,
      vjust = .5
    )
  )
```


A common way to specify an ellipse is with a center point and the two distances from the center point *c* to the horizontal and vertical edges, *a* and *b*, respectively.

$$\left(\frac{x-c_x}{a}\right)^2+\left(\frac{y-c_y}{b}\right)^2=1$$


```{r abellipse}
a <- 4
b <- 3
c1 <- point(0,0)
e1 <- ellipse(c1, a = a, b = b)
```


```{r fig-abellipse}
#| fig-cap: An ellipse can be specified with a center, and semi-major radii.
#| code-fold: true
bp + 
  e1 + 
  segment(c1, 
          point(c(a, 0), c(0, b)), 
          color = my_colors, 
          label = label(
            label = paste0(c("*a* = ", "*b* = "), 
                           c(a, b)), 
            angle = 0)) +
  c1
```

# Foci

A circle has one focus, the center. If *a* &ne; *b*, an ellipse has two foci. 

```{r fig-foci}
#| fig-cap: An ellipse has two foci
bp + 
  e1 + 
  label("*F*~1~", e1@focus_1, plot_point = T, vjust = 1.2) +
  label("*F*~2~", e1@focus_2, plot_point = T, vjust = 1.2)
```


For any point *P* on the ellipse, the sum of PF~1~ and PF~2~ is 2*a* if *a* > *b* and 2*b* if *b* > *a*.

```{r fig-focilength}
#| fig-cap: The sum of distances from the foci is constant.
deg <- degree(61.5)

bp + 
  e1 + 
  label("*F*~1~", e1@focus_1, plot_point = T, vjust = 1.2) +
  label("*F*~2~", e1@focus_2, plot_point = T, vjust = 1.2) + 
  {P <- e1@point_at(deg)} +
  P@label("*P*", polar_just = polar(deg, 1.5)) +
  segment(e1@focus_1, 
          P, 
          label = paste0("*PF*~1~ = ",
                         distance(e1@focus_1, P) |>
                           round())) + 
  segment(P, 
          e1@focus_2, 
          label = paste0("*PF*~2~ = ",
                         distance(e1@focus_2, P) |> 
                           round())) + 
  label("*PF*~1~ + *PF*~2~ = 2*a* = 8", 
        p = point(0,4), 
        size = 20)

```



## Point on the ellipse at a specific angle

```{r ptheta}
e1@point_at(degree(60))
```


```{r fig-ptheta}
#| fig-cap: Point on ellipse that is 45&deg; from the x-axis.
#| code-fold: true

deg <- degree(60)
bp +
  e1 +
  {p45 <- e1@point_at(deg)} +
  p45@label(polar_just = polar(deg, 1.5)) +
  segment(e1@center, p45) +
  arc(
    center = e1@center,
    radius = 1,
    start = degree(0),
    end = deg,
    label = deg
  )


  
```


# Superellipses

The standard formula for an ellipse can be altered such that the squared entities can be raised to any positive number.

$$
\left(\frac{x-c_x}{a}\right)^{m_1}+\left(\frac{y-c_y}{b}\right)^{m_2}=1
$$

*m*~2~ is set equal to *m*~1~ unless otherwise specified.

If *m*~1~ is 4, and *a* and *b* are equal, we can make a *squircle*, which is a square-ish circle.


```{r fig-squircle}
#| fig-cap: A squircle 
bp + 
  ellipse(a = 3, 
          b = 3, 
          m1 = 4)
```

If we increase *m*~1~ to a high value like 10, we can a rectangle with pleasingly rounded corners.

```{r fig-myvariable}
#| fig-cap: A superellipse can look like a rectangle with rounded corners.
bp +
  ellipse(
    a = 3,
    b = 3,
    m1 = 10,
    color = NA,
    fill = "dodgerblue",
    label = label(
      label = "My<br>Variable",
      fill = NA,
      color = "white",
      size = 70
    )
  )
  
```

# Connection Paths Among Ellipses

```{r fig-connectellipse}
#| fig-cap: Connections between ellipses
bp + 
  {e1 <- ellipse(point(-2,0), a = 2)} +
  {e2 <- ellipse(point(3,2), b = 2)} +
  connect(e1, e2, resect = 2)
```


# Placing Ellipses

The `place` function will set an object at a position and distance from another object. Here we set an ellipse to the the right of `e1` (i.e., "east" or 0 degrees) with a separation of 2.

```{r fig-placeellipse}
#| fig-cap: Place an ellipse 2 units to the right of another ellipse.
bp + 
  {e1 <- ellipse(center = point(-2, 0), 
                 a = 2)} +
  place(ellipse(b = 2), 
        from = e1, 
        where = "right", 
        sep = 2)
```


The `sep` parameter in the `place` function is not necessarily the shortest distance between ellipses. Instead, it is the distance between the ellipses on the segment connecting the center points. 

```{r fig-placedistance}
#| fig-cap: The separation distance between ellipses is along the path that connects their centers.
deg <- degree(30)

bp + 
  {e1 <- ellipse(point(-2,-1, 
                       color =  "dodgerblue4"), 
                 a = 2, 
                 b = 1.5)} +
  {e2 <- place(ellipse(point(color = "orchid4"),
                       b = 2), 
               from = e1, 
               where = deg, 
               sep = 2)} + 
  connect(e1, e2, 
       arrow_head = ggarrow::arrow_head_minimal(), 
       linetype = "dashed", 
       label = label(2, vjust = 0)) +
  arc(e1@center, end = deg, label = deg) + 
  segment(e1@center, e1@point_at(deg)) + 
  segment(e2@center, e2@point_at(deg + degree(180))) + 
  label("*e*~1~", e1@center) + 
  label("*e*~2~", e2@center)

```

You can place many ellipses at once. In @fig-manyconnections, 12 ellipses are placed around the central ellipse. Connection paths are then drawn to each ellipse.

```{r fig-manyconnections}
#| fig-cap: Many ellipses can be placed at once.

# Number of ellipses
k <- 12

# Colors
e_fills <- hsv(h = seq(0, 1 - 1 / k, length.out = k), 
               s = .4, 
               v = .6)

bp + 
  {e_0 <- ellipse(m1 = 6, 
                 label = label("*e*~0~", 
                               size = 40, 
                               color = "white", 
                               fill = "gray20"),
                 color = NA,
                 fill = "gray20")} + 
  {e_x <- place(
    x = ellipse(a = .4, 
                b = .4, 
                m1 = 6, 
                label = label(paste0("*e*~", seq(k), "~"), 
                              color = "white", 
                              fill = e_fills),
                color = NA,
                fill = e_fills),
    from = e_0,
    where = degree(seq(0, 360 - 360 / k, 360 / k)),
    sep = 2
  )} +
  connect(e_0, 
          e_x, 
          resect = 2, 
          color = e_fills) + 
  theme_void()
```

Lines can be placed in relation to ellipses:

```{r fig-placeline}
#| fig-cap: A line placed 3 units and 45 degrees from a squircle.
bp + 
  {e1 <- ellipse(m1 = 4)} +
  {l1 <- place(x = line(), 
               from = e1, 
               where = {deg1 <- degree(45)}, 
               sep = {d = 3})} + 
  connect(e1, l1, 
          label = paste0("Distance = ", d),           
          arrow_fins = arrowheadr::arrow_head_deltoid(), 
          length_fins = 8, 
          length_head = 8, 
          resect = 1) + 
  label(label = l1@equation, 
        p = polar(theta = deg1, 
                  r = e1@point_at(deg1)@r + d), 
        angle = l1@angle, 
        vjust = 0)
```

