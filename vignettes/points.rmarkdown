---
title: "Points"
format: 
  html:
    toc: true
vignette: >
  %\VignetteIndexEntry{points}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

```{r presetup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  dev = "ragg_png",
  comment = "#>",
  fig.width = 7,
  fig.height = 7
)
library(ggdiagram)
library(ggplot2)
library(dplyr)
library(ggtext)
my_font <- "Roboto Condensed"
gdtools::register_gfont(family = my_font)
gdtools::addGFontHtmlDependency(family = my_font)
```



# Setup

## Packages



```{r setup}
library(ggdiagram)
library(ggplot2)
library(dplyr)
library(ggtext)

```



## Base plot

To avoid repetitive code, we make a base plot:



```{r baseplot}
my_font <- "Roboto Condensed"
my_text_size <- 20
my_point_size <- 3
update_geom_defaults(geom = "richtext", 
                     new = list(family = my_font, 
                                size = .8 * my_text_size / ggplot2::.pt))

update_geom_defaults("point", list(my_point_size = 3))


theme_set(
  theme_minimal(
    base_size = my_text_size, 
    base_family = my_font) +
    theme(axis.title.y = element_text(angle = 0, vjust = 0.5)))




bp <- ggplot() +
  coord_equal(xlim = c(0, 5), ylim = c(0, 5))
  

bp

```





# Points

Points have x and y coordinates. 



```{r points}
p1 <- point(1, 2, color = "red")
p2 <- point(5, 4, color = "black")
```

```{r plot12}
pts <- c_gg(p1, p2)
bp +
  pts
```




## Polar Coordinates

A point's x and y coordinates can be specified in polar coordinates

* `@r`: The distance from the origin to the point (i.e., the vector's magnitude)
* `@theta`: The angle (in radians) from the line on the x-axis to the line containing the vector.



```{r rtheta}
p2
p2@r
p2@theta
```

```{r plotpolar}
a <- arrow_segment(p1 = p1, p2 = p2, resect_head = 2)

bp +
  p2 +
  a +
  label(p = midpoint(a),
        label = distance(a),
        angle = a@line@angle,
        vjust = 0)
```




A point can be created with polar coordinates



```{r polar}
polar(r = 5, theta = degree(60))

cos(degree(60)) * 5
```



If the angle is numeric instead of an angle, it is assumed to be in radians. 



```{r}
point(r = 1, theta = pi)@theta

```




A point can be converted to a 1 &times; 2 matrix:



```{r}
p1@xy
as.matrix(p1)
```



# Convert to tibble

This will extract any styles that have been set.



```{r}
get_tibble(point(1,2, color = "red", shape = 16))
```




# Methods

## Arithmetic

Points can be added and subtracted:



```{r}
p1 <- point(2, 3)
p2 <- point(2, 1)
p3 <- p1 + p2
p3
p3 - p2
```



Points can be scaled with constants



```{r}
p2 * 2
p3 / 4
```



The x and y coordinates can be scaled separately with other points:



```{r}
p1 / p3
p1 * p3

point(1:2, 1) * point(3,2)
```




# Distance

The distance between two points:



```{r}
distance(p1, p2)
```



The shortest distance from a point to a line:



```{r}
l1 <- line(slope = 1, intercept = 2)
distance(p1, l1)
```



The shortest distance from a point to a circle's edge:



```{r}
c1 <- circle(center = point(2, 2), radius = 2)
p1 <- c1@center + polar(r = c1@radius, theta = degree(115))
p2 <- c1@center + polar(r = c1@radius * 2, theta = degree(45))
p3 <- c1@center + polar(r = c1@radius * .3, theta = degree(190))
# p1 is on circle, so its distance is 0
distance(p1, c1)
# p2 is outside the circle
distance(p2, c1)
# p3 is inside the circle
distance(p3, c1)
distance(c1, c1@center)

pts <- point_list(c(p1, p2, p3))
intersect_c1_p2 <- anchor(c1, (p2 - c1@center)@theta)
seg_c1_p2 <- segment(p2, intersect_c1_p2)

intersect_c1_p3 <- anchor(c1, (p3 - c1@center)@theta)
seg_c1_p3 <- segment(p3, intersect_c1_p3)
bp +
  c1 +
  pts +
  label(pts, vjust = 0, label = paste0("p", seq(length(pts)))) + 
  intersect_c1_p2 +
  seg_c1_p2 +
  label(seg_c1_p2, distance(seg_c1_p2)) + 
  intersect_c1_p3 +
  seg_c1_p3 +
  label(seg_c1_p3, distance(seg_c1_p3))
  


```

```{r}
bp + 
  # xlim(-3,3) + 
  # ylim(-3,3) +
  p1


```





# Point Lists

Points can be concatenated in a list like any other object.



```{r}
c(p1, p2)
```



However, extracting properties from that list is more convenient if the list is made into a `point_list`.



```{r}
pts <- point_list(c(p1, p2, p3))
pts@x
pts@y
pts@r
pts@theta@degree
```

```{r}
ggplot() +
  coord_equal() +
  pts
```




A list of points can also be created with x and y vectors separately:



```{r}
x <- c(2, 4, 5, 0)
y <- c(0, 4, 2, 5)
pts <- point(x, y)
```



A point list can also be created directly from a two-column matrix:



```{r}
# A two-column matrix from x and y
m <- cbind(x,y)
pts <- point(m)
```

```{r}
ggplot() +
  coord_equal() +
  pts


```




## Point_list data

A `point_list` is a list, and behaves like a list should



```{r}
p1 <- point(3, 4, color = "red")
p2 <- point(2, 3, size = 6)

pts <- point_list(c(p1,p2))
pts[[1]]


```



To get just the xy coordinates, use the `@xy` property.



```{r}
pts@xy
```



To get a tibble with any style information that has been set:



```{r}
get_tibble(pts)
```



The `get_tibble_defaults` function gets the same tibble, but with any missing style information filled with defaults:



```{r}
get_tibble_defaults(pts)
```



These defaults can be updated with `ggplot2::update_geom_defaults`:



```{r}
ggplot2::update_geom_defaults("point", list(size = 2, color = "royalblue"))
get_tibble_defaults(pts)

```




# Convert points to geoms

First, let's this straight. If all you need to do make a scatterplot, just make one the standard way with ggplot2's standard functions. However, if you have reason to make points with ggpathdiagramr and then plot them, then `as.geom` function can help.

The `as.geom` function is called implicitly whenever a point or point list is added to a ggplot.



```{r}
ggplot() + 
  pts
```



This is equivalent to 



```{r}
ggplot() +
  as.geom(pts)
```



And this is equivalent to 



```{r}
ggplot() +
  geom_point(
    aes(
      x,
      y,
      color = I(color),
      size = I(size)), 
    data = get_tibble_defaults(pts))
```



That is, any style information will be handled via the `I` (identity) function in the mapping statement (`aes`).

Calling the `as.geom` function directly is useful for overriding any style information in the points. 



```{r}
ggplot() + 
  as.geom(pts, 
          stroke = 1.5,
          fill = "yellow", 
          shape = "triangle filled")
```



This is equivalent to 



```{r}
ggplot() +
  geom_point(
    aes(x = x, 
        y = y, 
        size = I(size), 
        color = I(color)),
    stroke = 1.5,
    fill = "yellow",
    shape = "triangle filled",
    data = get_tibble_defaults(pts)
  )
```

