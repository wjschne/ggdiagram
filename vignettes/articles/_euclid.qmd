---
title: "Euclid's Amber Version of the Elements"
format: 
  html:
    toc: true
    toc-location: left
    code-fold: false
    html-math-method: katex
    backgroundcolor: "#fcf3d9"
    mainfont: "Libre Caslon Text"
    theme: [amber.scss]
vignette: >
  %\VignetteIndexEntry{elements}
  %\VignetteEngine{quarto::format}
  %\VignetteEncoding{UTF-8}
---

```{r}
#| label: setup
#| include: false

library(ggdiagram)
library(ggplot2)
red <- "#d42a20"
yellow <- "#D6A624"
blue <- "#0C7AA5"
black <- "#000000"
bg <- "#fcf3d9"
gray <- "#656565"
my_font <- "Libre Caslon Text"
knitr::opts_chunk$set(
  collapse = TRUE,
  dev = "ragg_png",
  dev.args = list(background = bg),
  comment = "#>",
  fig.width = 7,
  fig.height = 7
)

ggplot2::update_geom_defaults(ggforce::GeomCircle, list(linewidth = 2))
baseplot <- ggdiagram(
  panel.background = element_rect(bg, color = NA),
  plot.background = element_rect(bg, 
                                 color = NA),
  font_family = my_font, 
  linewidth = 2, font_size = 18)
```



**NOTE**. The text of this tutorial is a mostly word-for-word---including jokes---adaptation of a [TikZ tutorial of the same name](https://tikz.dev/tutorial-Euclid). I adapted the tutorial to see if ggdiagram could duplicate TikZ's capabilities, and made changes to the wording only in places that were required to translate concepts and code from TikZ/LaTeX to ggdiagram/R.

In this tutorial, we have a look at how ggdiagram can be used to draw geometric constructions.

Euclid is currently quite busy writing his new book series, whose working title is *Elements* (Euclid is not quite sure whether this title will convey the message of the series to future generations correctly, but he intends to change the title before it goes to the publisher). Up to now, he wrote down his text and graphics on papyrus, but his publisher suddenly insists that he must submit in electronic form. Euclid tries to argue with the publisher that electronics will only be discovered thousands of years later, but the publisher informs him that the use of papyrus is no longer cutting edge technology, and Euclid will just have to keep up with modern tools.

Slightly disgruntled, Euclid starts converting his papyrus entitled *Book I, Proposition I* to an amber version.

# Book I, Proposition I

:::{.callout-note title="Proposition I"}

```{r}
#| label: fig-equilateral
#| fig-width: 6
#| fig-height: 4
#| fig-cap: "Make an equilateral trigangle starting with line AB."
#| echo: false
#| fig-column: margin

# Radius
r <- 1

# Points A and B
pA <- ob_point(0, 0)
pB <- ob_polar(degree(0), r)

# Circles
cBCD <- ob_circle(pA, r, color = blue)
cACE <- ob_circle(pB, r, color = red)

# Intersection of circles to make equilateral triangle
pC <- intersection(cBCD, cACE)[1]

# Points to label circles
pD <- cBCD@point_at(180)
pE <- cACE@point_at(0)

# Segments AC and BC
sAB <- ob_segment(pA, pB, color = black)
sAC <- ob_segment(pA, pC, color = yellow)
sBC <- ob_segment(pB, pC, color = red)

# Bind segments
sABC <- bind(c(sAB, sAC, sBC))

# Hatch marks to note congruence
hABC <- sABC@hatch(linewidth = .75) 

# Make point labels
lABCDE <- ob_label(
  LETTERS[1:5],
  bind(c(pA, pB, pC, pD, pE)),
  fill = bg,
  color = c(red, blue, black, blue, red),
  size = 22,
  family = my_font,
  vjust = .5,
  label.padding = margin(4,3,0,3),
  label.r = unit(9, units = "pt")
)

baseplot +
  sABC +
  cBCD +
  cACE +
  lABCDE +
  hABC
```

To construct an equilateral triangle on a given finite straight-line.

Let AB be the given finite straight-line.

So it is required to construct an equilateral triangle on the straight-line AB.

Let the circle BCD with center A and radius AB have been drawn, and again let the circle ACE with center B and radius BA have been drawn. And let the straight-lines CA and CB have been joined from the point C, where the circles cut one another, to the points A and B (respectively).

And since the point A is the center of the circle CDB, AC is equal to AB. Again, since the point B is the center of the circle CAE, BC is equal to BA. But CA was also shown (to be) equal to AB. Thus, CA and CB are each equal to AB. But things equal to the same thing are also equal to one another. Thus, CA is also equal to CB. Thus, the three (straight lines) CA, AB, and BC are equal to one another.

Thus, the triangle ABC is equilateral, and has been constructed on the given finite straight-line AB.

:::


Let us have a look at how Euclid can turn this into R code with ggdiagram.

## Setting up the Environment

First we need to load some R packages and define some colors:


```{r loading}
library(ggplot2)
library(ggdiagram)
red <- "#d42a20"
yellow <- "#D6A624"
blue <- "#0C7AA5"
black <- "#000000"
gray <- "#656565"
```

## The Line *AB*

The first part of the picture that Euclid wishes to draw is the line *AB*. That is easy enough, something like `ob_segment(x = 0, xend = 0, y = 2, yend = 1)` might do. However, Euclid does not wish to reference the two points *A* and *B* as raw numbers. Rather, he wishes to just write `A` and `B`. Indeed, the whole point of his book is that the points *A* and *B* can be arbitrary and all other points (like *C*) are constructed in terms of their positions. It would not do if Euclid were to write down the coordinates of *C* explicitly. 
 explicitly.

So, Euclid starts with defining two coordinates using the `ob_point` function:

```{r ab, fig.height=3}
A <- ob_point(0, 0)
B <- ob_point(2, 1)
AB <- ob_segment(A, B, color = blue)

ggdiagram() +
  AB
```


That was easy enough. What is missing at this point are the labels for the coordinates. Euclid does not want them on the points, but next to them. He decides to use the label slot on points `A` and `B`:


```{r ablabel, fig.height=3}
ggdiagram(font_size = 16, 
          font_family = my_font) +
  AB +
  A@label("A", hjust = 1, color = blue, fill = NA) +
  B@label("B", hjust = 0, color = blue, fill = NA)
```

At this point, Euclid decides that it would be even nicer if the points *A* and *B* were in some sense "random." Then, neither Euclid nor the reader can make the mistake of taking "anything for granted" concerning these position of these points. Euclid is pleased to learn that there is a rand function in R that does exactly what he needs: `runif`. It produces a number between any two numbers. Here we want a unit vector between &minus;1 and 1. Since R can do a bit of math, Euclid can change the coordinates of the points as follows:


```{r randomab}
A <- ob_point(
  x = 0 + 0.1 * runif(1, -1, 1),
  y = 0 + 0.1 * runif(1, -1, 1)
)

B <- ob_point(
  x = 1.25 + 0.1 * runif(1, -1, 1),
  y = 0.25 + 0.1 * runif(1, -1, 1)
)

AB <- ob_segment(A, B, color = blue)
```


This works fine. However, Euclid is not quite satisfied since he would prefer that the "main coordinates" (0, 0) and (1.25, 0.25) are "kept separate" from the perturbation &pm;0.1. This means, he would like to specify that coordinate *A* as the point that is at (0, 0) plus one tenth of a random unit vector.

It turns out that the R allows him to do exactly this kind of computation. We can define a custom function `rvector` that creates a random unit vector that is scaled by any amount we like.

The new code for the coordinates is the following:

```{r vablabel, fig.height=2}
set.seed(123)
rvector <- function(scalar = 1) {
  scalar * ob_point(
    runif(n = 1, min = -1, max = 1),
    runif(n = 1, min = -1, max = 1)
  )
}
A <- ob_point(0, 0) + rvector(1)
B <- ob_point(1.25, 0.25) + rvector(1)
AB <- ob_segment(A, B, color = blue)

ggdiagram(font_size = 16, font_family = my_font) +
  AB +
  A@label("A", hjust = 1, color = blue, fill = NA) +
  B@label("B", hjust = 0, color = blue, fill = NA)
```

## The Circle Around A

The first tricky construction is the circle around *A*. We will see later how to do this in a very simple manner, but first let us do it the "hard" way.

The idea is the following: We draw a circle around the point *A* whose radius is given by the length of the line *AB*. The difficulty lies in computing the length of this line.

Euclid could compute the distance by hand using the Euclidean distance (Ha!):

$$
d=\sqrt{(B_x-A_x)^2 + (B_y-A_y)^2}
$$

Euclid could write the following:

```{r dab}
sqrt((B@x - A@x) ^ 2 + (B@y - A@y) ^ 2)
```

However, objects created with the `ob_segment` function have a distance slot that performs this calculation automatically:

```{r abdistance}
AB@distance
```

Thus, circles `D` and `E` can be created like so:


```{r circlesDE, fig.height=5}
D <- ob_circle(center = A, radius = AB@distance)
E <- ob_circle(center = B, radius = AB@distance)

ggdiagram(font_size = 16, font_family = my_font) +
  AB +
  A@label("A", hjust = 1, color = blue, fill = NA) +
  B@label("B", hjust = 0, color = blue, fill = NA) + 
  D + 
  E + 
  D@west@label("D", hjust = 1.1, fill = NA) +
  E@east@label("E", hjust = -0.1, fill = NA)
```

# The Intersection of the Circles

Euclid can now draw the line and the circles. The final problem is to compute the intersection of the two circles. This computation is a bit involved if you want to do it "by hand." Fortunately, the `intersection` function allows us to compute the intersection of two circles. In this case, there are two points of intersection, *C* and *C'*. For point *C*, we will take the first of the two intersection points between circles *D* and *E*.


```{r intersectDE, fig.height=5}
intersect_DE <- intersection(D, E)
C <- intersect_DE[1]

AC <- ob_segment(A, C, color = red)
BC <- ob_segment(B, C, color = red)
ABC <- bind(c(AB, BC, AC))

pABC <- bind(c(A,B,C))

ggdiagram(font_size = 16, font_family = my_font) +
  ABC +
  ABC@hatch() +
  ob_label(c("A", "B", "C"), 
           center = pABC, 
           polar_just = (pABC - pABC@centroid) * 2, 
           color = c(blue, blue, gray), 
           fill = NA, 
           plot_point = TRUE) +
  D + 
  E + 
  D@west@label("D", hjust = 1.1, fill = NA) +
  E@east@label("E", hjust = -0.1, fill = NA)
```

Although Euclid does not need it for the current picture, it is just a few steps to compute the bisection of the line *AB*:

```{r cprime, fig.height=5}
Cprime <- intersect_DE[2]
CCprime <- ob_segment(intersect_DE, color = red)
pF <- intersection(AB, CCprime, color = red)
ggdiagram(font_size = 16, font_family = my_font) +
  ABC +
  A@label("A", hjust = 1, color = blue, fill = NA) +
  B@label("B", hjust = 0, color = blue, fill = NA) + 
  D + 
  E + 
  D@west@label("D", hjust = 1.1, fill = NA) +
  E@east@label("E", hjust = -0.1, fill = NA) +
  C@label("C", vjust = -.2, hjust = .6, fill = NA) +
  Cprime@label("C&prime;", vjust = 1.3, fill = NA) +
  CCprime + 
  pF +
  pF@label("F", vjust = 1.1, hjust = -.3, fill = NA)

```

## Proposition I: The Complete Code

Back to Euclid’s code. He uses the background layer for drawing the triangle behind everything at the end.


```{r}
#| label: fig-completeab
#| fig-cap: "Proposition I: Construct an equilateral triangle on a given finite straight-line"
#| fig-height: 5
rvector <- function(scalar = 1) {
  scalar * ob_point(
    runif(n = 1, min = -.1, max = .1),
    runif(n = 1, min = -.1, max = .1)
  )
}

ggdiagram(font_size = 16, font_family = my_font) +
  {A <- ob_point(0, 0) + rvector(.1)} +
  {B <- ob_point(1.25, 0.25) + rvector(.1)} +
  {AB <- ob_segment(A, B, color = blue)} +
  {D <- ob_circle(A, radius = AB@distance)} +
  {E <- ob_circle(B, radius = AB@distance)} + 
  D@point_at((A - B)@theta)@label(
    label = "D", 
    polar_just = (A - B)@theta, 
    fill = NA) +  
  E@point_at((B - A)@theta)@label(
    label = "E", 
    polar_just = (B - A)@theta, 
    fill = NA) +
  {C <- intersection(D, E)[1]} +
  ob_polygon(p = {p_ABC <- bind(c(A, B, C))}, 
             color = NA, 
             fill = class_color("orange")@lighten(.3)) +
  {s_ABC <- ob_segment(bind(c(A,B,C,A)), color = c(red, blue, blue))} + 
  s_ABC@hatch() +
  p_ABC +
  ob_label(LETTERS[1:3], 
           center = p_ABC, 
           polar_just = (p_ABC - p_ABC@centroid) * 2, 
           fill = NA, 
           color = c(red,red, blue))
```


# Book I, Proposition II

The second proposition in the Elements is the following:

:::{.callout-note title="Proposition II"}

```{r}
#| label: fig-prop2
#| fig-cap: "Proposition II: Draw a segment of the same size as another segment from an arbitrary point."
#| fig-column: margin
#| echo: false
my_segment <- redefault(ob_segment, color = gray)

my_label <- redefault(
  ob_label,
  color = gray,
  fill = NA,
  size = 30,
  plot_point = TRUE, 
  label.margin = margin(3,3,3,3, "pt")
)
ggdiagram(font_family = my_font) +
  {A <- ob_point()} + 
  {B <- ob_point(1, .2)} + 
  {C <- ob_point(1, 2.5)} + 
  {BC <- my_segment(B, C, color = blue, linewidth = 1)} + 
  {AB <- my_segment(A, B)} +
  {D <- intersection(ob_circle(A, AB@distance),
                     ob_circle(B, AB@distance))[1]} +
  {AD <- my_segment(A, D)}  +
  {DB <- my_segment(D, B)} +
  {AE <- AD@line |> set_props(color = "transparent")} +
  {BF <- DB@line |> set_props(color = "transparent")} + 
  {CGH <- ob_circle(B, BC@distance, color = gray)} + 
  {G <- intersection(BF, CGH)[1]} +
  {DG <- my_segment(D, G)} +
  {GKL <- ob_circle(D, DG@distance, color = gray)} + 
  {L <- intersection(AE, GKL)[2]} + 
  {E <- AE@point_at_y(L@y - .5)} +
  {`F` <- BF@point_at_y(G@y - .5)} +
  {AL <- my_segment(A, L, color = red, linewidth = 1)} +
  my_label("A", A, polar_just = (A - B)@theta, color = yellow) +
  my_label("B", B, polar_just = (B - A)@theta, color = blue) +
  my_label("C", C, polar_just = (C - B)@theta, color = blue) +
  my_label("D", D, polar_just = (D - AB@midpoint())@theta, color = gray) +
  connect(L, E, color = gray) +
  connect(G, `F`, color = gray) +
  my_label("E", E, polar_just = (E - L)@theta) + 
  my_label("F", `F`, polar_just = (`F` - G)@theta, color = gray) + 
  my_label("G", G, polar_just = degree(-10)) + 
  my_label("L", L, polar_just = degree(-65), color = red) + 
  my_label("H", intersection(BF, CGH)[2], polar_just = (D - B)@theta, plot_point = FALSE) +
  my_label("K", intersection(BF, GKL)[2], polar_just = (D - B)@theta, plot_point = FALSE) +
  scale_y_continuous(NULL, breaks = NULL, minor_breaks = NULL, expand = expansion(c(.1, .01)))
```

To place a straight line equal to a given straight line with one end at a given point.

Let A be the given point, and BC the given straight line. It is required to place a straight line equal to the given straight line BC with one end at the point A.

Join the straight line AB from the point A to the point B, and construct the equilateral triangle DAB on it.

Produce the straight lines AE and BF in a straight line with DA and DB. Describe the circle CGH with center B and radius BC, and again, describe the circle GKL with center D and radius DG.

Since the point B is the center of the circle CGH, therefore BC equal BG. Again, since the point D is the center of the circle GKL, therefore DL equals DG. And in these DA equals DB, therefore the remainder AL equals the remainder BG. But BC was also proved equal to BG, therefore each of the straight lines AL and BC equal BG. And things which equal the same thing also equal one another, therefore AL also equal BC.

Therefore, the straight line AL equal to the given straight line BC has been placed with one end at the given point A.
:::

## Using Partway Calculations for the Construction of Point D

Euclid’s construction starts with "referencing" Proposition I for the construction of the point D. Now, while we could simply repeat the construction, it seems a bit bothersome that one has to draw all these circles and do all these complicated constructions.

For this reason, ggdiagram supports some simplifications. The `midpoint` function can be called on two `ob_point`s or on an `ob_segment` (or an `ob_arc`). Also, `ob_segment` has a slot function such that `AB@midpoint()` is the same as `midpoint(AB)`.

Here is the computation of the point in the middle of the line AB:

```{r plotAB, fig.height=2}
my_segment <- redefault(ob_segment, color = gray)
my_label <- redefault(
  ob_label,
  color = gray,
  fill = NA,
  size = 18,
  plot_point = TRUE, 
  label.margin = margin(3,3,3,3, "pt")
)
plot_AB <- ggdiagram(font_family = my_font) +
  {A <- ob_point()} + 
  {B <- ob_point(1, .2)} + 
  {AB <- my_segment(A, B)} +
  my_label("A", A, polar_just = (A - B)@theta) + 
  my_label("B", B, polar_just = (B - A)@theta) 
plot_AB +
  {X <- midpoint(A, B, color = red)} +
  my_label("X", X, polar_just = (B - A)@theta - degree(90)) 
```

The computation of point D could be calculated in many ways. The traditional way is to take the intersection of two circles centered at the two points, with the same radius as distance between the points. 

```{r plotABD}
plot_AB + 
  {D <- intersection(
    ob_circle(A, AB@distance),
    ob_circle(B, AB@distance))[1]} 
```


Here we we rotate AB by 60 degrees and take the second point in the segment:

```{r ABDrotate}
plot_AB + 
  {D <- rotate(AB, degree(60))@p2} 
```

Of course, equilateral triangles are more easily created with the `ob_ngon` function, which makes regular polygons.

```{r ABDngon}
ggdiagram(font_family = my_font) + 
  {ABD <- ob_ngon(
    n = 3, 
    color = gray, 
    fill = NA, 
    angle = degree(-140))} +
  ABD@vertices@label(
    label = c("A", "B", "D"), 
    polar_just = (ABD@vertices - ABD@center) * 1.5, 
    size = 16, 
    plot_point = TRUE,
    fill = NA)
```

## Intersecting a Line and a Circle

```{r plot_CGH}
plot_CGH <- plot_AB + 
  D + 
  ob_path(bind(c(B, D, A))) +
  {C <- ob_point(1.5, 2.5)} +
  {BC <- my_segment(B, C)} +
  {CGH <- ob_circle(B, BC@distance, color = gray)} + 
  {DE <- connect(D, A + (A - D) * 3, color = gray)} + 
  {DF <- connect(D, B + (B - D) * 3, color = gray)} + 
  {G <- intersection(DF, CGH)} + 
  DF@p2@label("F", size = 16, fill = NA, polar_just = (B - D)@theta, color = gray) +
  DE@p2@label("E", size = 16, fill = NA, polar_just = (A - D)@theta, color = gray) +
  D@label(
    "D",
    polar_just = (D - AB@midpoint())@theta,
    size = 16,
    color = gray,
    plot_point = TRUE,
    fill = NA
  ) +
  C@label(
    "C",
    polar_just = (C - B)@theta,
    size = 16,
    plot_point = TRUE,
    fill = NA
  ) +
  G@label(
    "G",
    size = 16,
    fill = NA,
    nudge_x = .2,
    color = red
  ) + 
  A +
  B +
  CGH@point_at(
    theta = (G - B)@theta + degree(180))@label(
      label = "H",
      polar_just = (D - B) * 1.5,
      size = 16,
      fill = NA
  )

plot_CGH
```


## Proposition II: The Complete Code

```{r complete2}
ggdiagram(font_family = my_font) +
  {A <- ob_point()} + 
  {B <- ob_point(1, .2)} + 
  {AB <- my_segment(A, B)} +
  my_label(label = "A", 
           center = A, 
           polar_just = (A - B)@theta, 
           color = yellow) + 
  my_label(label = "B", 
           center = B, 
           color = blue,
           polar_just = (B - A)@theta)  + 
  {D <- rotate(AB, degree(60))@p2} +
  {C <- ob_point(1.5, 2.5)} +
  {BC <- my_segment(B, C, color = blue)} +
  {CGH <- ob_circle(B, BC@distance, color = gray)} + 
  {DE <- connect(D, A + (A - D) * 3, color = gray)} + 
  {DF <- connect(D, B + (B - D) * 3, color = gray)} + 
  {G <- intersection(DF, CGH)} + 
  DF@p2@label("F", size = 16, fill = NA, polar_just = (B - D)@theta, color = gray) +
  DE@p2@label("E", size = 16, fill = NA, polar_just = (A - D)@theta, color = gray) +
  D@label(
    "D",
    polar_just = (D - AB@midpoint())@theta,
    size = 16,
    color = gray,
    plot_point = TRUE,
    fill = NA
  ) +
  C@label(
    "C",
    polar_just = (C - B)@theta,
    size = 16,
    plot_point = TRUE,
    color = blue,
    fill = NA
  ) +
  G@label(
    "G",
    size = 16,
    nudge_x = .25,
    nudge_y = -.05,
    color = gray,
    fill = NA
  ) + 
  A +
  B +
  CGH@point_at(
    theta = (G - B)@theta + degree(180))@label(
      label = "H", 
      fill = NA,
      polar_just = (D - B) * 1.5, 
      size = 16) +
  {GKL <- ob_circle(D, distance(D, G), color = gray)} + 
  {L <- intersection(GKL, DE)} +
  my_segment(A, L, color = red) + 
  GKL@point_at(
    theta = (G - B)@theta + degree(180))@label(
      label = "K", 
      fill = NA,
      polar_just = (D - B) * 1.5, 
      size = 16) + 
  L@label(
    label = "L", 
    polar_just = ob_polar(degree(-65), 1.5), 
    size = 16, 
    fill = NA, 
    color = red) +
  bind(c(A, B, C, D, G, L), color = gray, size = 2)
```

