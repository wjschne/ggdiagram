{
  "hash": "bd61f3998ea093ad932e050d996bc91a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Repetition and Automation\"\nformat: \n  html:\n    toc: true\n    html-math-method: katex\nvignette: >\n  %\\VignetteIndexEntry{automation}\n  %\\VignetteEngine{quarto::html}\n  %\\VignetteEncoding{UTF-8}\n---\n\n\n\n\n\n# Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggdiagram)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggtext)\nlibrary(ggarrow)\nlibrary(purrr)\n```\n:::\n\n\n\n\n\n# Object Lists\n\n\nAny ggdiagram object made with `ob_*` functions can be made into a list, either with the `list` function or the `c` function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- ob_point(1, 2)\np2 <- ob_point(3, 4)\nc(p1,p2)\n#> [[1]]\n#> S3<ggdiagram::ob_point/ggdiagram::xy/ggdiagram::shape/ggdiagram::has_style/S7_object>\n#> @ x: num 1\n#> @ y: num 2\n#> Other props: alpha, color, fill, shape, size, stroke, auto_label,\n#>              bounding_box, centroid, length, r, theta, style,\n#>              tibble, xy, geom, label, place, aesthetics\n#> \n#> [[2]]\n#> S3<ggdiagram::ob_point/ggdiagram::xy/ggdiagram::shape/ggdiagram::has_style/S7_object>\n#> @ x: num 3\n#> @ y: num 4\n#> Other props: alpha, color, fill, shape, size, stroke, auto_label,\n#>              bounding_box, centroid, length, r, theta, style,\n#>              tibble, xy, geom, label, place, aesthetics\n```\n:::\n\n\n# Binding lists of objects into a single object\n\nThe `bind` function will take a list of the ggdiagram objects and a create single object. If all objects in the list are of a single type (e.g., `ob_point`), `bind` will return an object of that type. If the objects are of multiple types, `bind` will bind each type of object separately and return a `ob_shape_list`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- bind(c(p1,p2))\np\n#> S3<ggdiagram::ob_point/ggdiagram::xy/ggdiagram::shape/ggdiagram::has_style/S7_object>\n#> @ x: num [1:2] 1 3\n#> @ y: num [1:2] 2 4\n#> Other props: alpha, color, fill, shape, size, stroke, auto_label,\n#>              bounding_box, centroid, length, r, theta, style,\n#>              tibble, xy, geom, label, place, aesthetics\n```\n:::\n\n\n\nBinding objects can make subsequent tasks easier and less repetitive. For example, from the new object `p`, we can create two circles with one line of code rather than the two lines that would otherwise be needed to create separate circles from `p1` and `p2`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggdiagram() +\n  ob_circle(center = p)\n```\n\n::: {.cell-output-display}\n![](automation_files/figure-html/circle-1.png){width=672}\n:::\n:::\n\n\n\nWith only two points, the time savings is small. When many objects are bound, the time savings can be substantial.\n\nIf the list of objects are of different types, the `bind` function will bind all objects of the same type and the resulting list will be an `ob_shape_list`. In @fig-osl we bind 2 points and 2 circles into a `ob_shape_list` that has 1 `ob_point` and 1 `ob_circle`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- ob_point(0,0)\np2 <- ob_point(2,0)\nc1 <- ob_circle(p1, radius = 2)\nc2 <- ob_circle(p2, radius = 1.5)\n\n# bind objectins into an ob_shape_list\nosl <- bind(c(p1, p2, c1, c2))\nosl\n#> <ob_shape_list>\n#> S3<ggdiagram::ob_point/ggdiagram::xy/ggdiagram::shape/ggdiagram::has_style/S7_object>\n#> @ x: num [1:2] 0 2\n#> @ y: num [1:2] 0 0\n#> Other props: alpha, color, fill, shape, size, stroke, auto_label,\n#>              bounding_box, centroid, length, r, theta, style,\n#>              tibble, xy, geom, label, place, aesthetics\n#> S3<ggdiagram::ob_circle/ggdiagram::centerpoint/ggdiagram::xy/ggdiagram::shape/ggdiagram::has_style/S7_object>\n#> @ center:S3<ggdiagram::ob_point/ggdiagram::xy/ggdiagram::shape/ggdiagram::has_style/S7_object>\n#> @ x: num [1:2] 0 2\n#> @ y: num [1:2] 0 0\n#> Other props: alpha, color, fill, shape, size, stroke, auto_label,\n#>              bounding_box, centroid, length, r, theta, style,\n#>              tibble, xy, geom, label, place, aesthetics\n#> @ radius: num [1:2] 2 1.5\n#> Other props: label, alpha, color, fill, linewidth, linetype,\n#>              n, area, bounding_box, circumference, diameter,\n#>              length, polygon, style, tibble, geom, arc, angle_at,\n#>              normal_at, tangent_at, place, point_at, aesthetics\n\nggdiagram() +\n  osl\n```\n\n::: {.cell-output-display}\n![An ob_shape_list](automation_files/figure-html/fig-osl-1.png){#fig-osl width=672}\n:::\n:::\n\n\n\nThere is not much benefit to making an `ob_shape_list` as shown here. It would simpler to just include the objects one at a time. However, it can be useful in the context of a large diagram with many elements, each of which would require a separate layer in ggplot2. Binding all the elements first can reduce the number of ggplot layers to the number of object types in the `ob_shape_list`.\n\nAn `ob_shape_list`'s underlying data is a named list. The names are the functions that were used to create the objects. For example,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nosl[[\"ob_point\"]]\n#> S3<ggdiagram::ob_point/ggdiagram::xy/ggdiagram::shape/ggdiagram::has_style/S7_object>\n#> @ x: num [1:2] 0 2\n#> @ y: num [1:2] 0 0\n#> Other props: alpha, color, fill, shape, size, stroke, auto_label,\n#>              bounding_box, centroid, length, r, theta, style,\n#>              tibble, xy, geom, label, place, aesthetics\nosl[[\"ob_circle\"]]\n#> S3<ggdiagram::ob_circle/ggdiagram::centerpoint/ggdiagram::xy/ggdiagram::shape/ggdiagram::has_style/S7_object>\n#> @ center:S3<ggdiagram::ob_point/ggdiagram::xy/ggdiagram::shape/ggdiagram::has_style/S7_object>\n#> @ x: num [1:2] 0 2\n#> @ y: num [1:2] 0 0\n#> Other props: alpha, color, fill, shape, size, stroke, auto_label,\n#>              bounding_box, centroid, length, r, theta, style,\n#>              tibble, xy, geom, label, place, aesthetics\n#> @ radius: num [1:2] 2 1.5\n#> Other props: label, alpha, color, fill, linewidth, linetype,\n#>              n, area, bounding_box, circumference, diameter,\n#>              length, polygon, style, tibble, geom, arc, angle_at,\n#>              normal_at, tangent_at, place, point_at, aesthetics\n```\n:::\n\n\n\n\n\n# Use `unbind` to make an object into a list of objects\n\nThe `unbind` function will perform the opposite operation as `bind`. It converts the elements of an object into a list of singleton objects. For example, object `p` has two points. Unbinding it will create a list of 2 `ob_point` objects.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunbind(p)\n#> [[1]]\n#> S3<ggdiagram::ob_point/ggdiagram::xy/ggdiagram::shape/ggdiagram::has_style/S7_object>\n#> @ x: num 1\n#> @ y: num 2\n#> Other props: alpha, color, fill, shape, size, stroke, auto_label,\n#>              bounding_box, centroid, length, r, theta, style,\n#>              tibble, xy, geom, label, place, aesthetics\n#> \n#> [[2]]\n#> S3<ggdiagram::ob_point/ggdiagram::xy/ggdiagram::shape/ggdiagram::has_style/S7_object>\n#> @ x: num 3\n#> @ y: num 4\n#> Other props: alpha, color, fill, shape, size, stroke, auto_label,\n#>              bounding_box, centroid, length, r, theta, style,\n#>              tibble, xy, geom, label, place, aesthetics\n```\n:::\n\n\n\nThe `unbind` function is needed when we want to loop through each element using `lapply` or `purrr::map`. Here we have two points and we want to put six points the both. We want to connect each element of one column to each element of the other column. Note that the output of `lapply` or `purrr::map` is a list. To make the list something that ggplot2 can plot, we can bind the list into a single object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntheta <- degree(seq(90, 360, 120))\nggdiagram() + \n  {p_3 <- ob_polar(\n        theta = theta,\n        r = .5,\n        fill = \"black\",\n        shape = \"triangle down filled\",\n        size = 15)} +\n  unbind(p_3) %>%\n    purrr::map(\n      \\(p_i) {\n        p_i + ob_polar(\n          theta = theta, \n          r = .15, \n          color = \"orchid\", \n          fill = \"orchid\", \n          size = 15, \n          shape = \"triangle filled\")}) %>% \n  bind() +\n  scale_x_continuous(NULL, expand = expansion(.15))\n```\n\n::: {.cell-output-display}\n![Using `unbind`, `map`, and `bind` to loop through elements.](automation_files/figure-html/fig-unbind-1.png){#fig-unbind width=480}\n:::\n:::\n\n\n\nAlternatively, we can convert each list item into a geom with `as.geom`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggdiagram() + \n  {p <- ob_polar(degree(seq(30,330,60)), \n                 r = 2, \n                 size = 10, \n                 color = \"orchid\")} +\n  unbind(p) %>% \n    lapply(\\(pp) {\n      p2 <- pp + ob_polar(\n        theta = degree(seq(0, 330, 30)),\n        r = .5)\n      \n      s <- connect(pp, p2)\n        \n      as.geom(s)\n      }) \n```\n\n::: {.cell-output-display}\n![Using `unbind`, `lapply`, and `as.geom` to loop through elements.](automation_files/figure-html/fig-unbindgeom-1.png){#fig-unbindgeom width=672}\n:::\n:::\n\n\n\n# Use `map_ob` to loop through object elements\n\nTo `unbind`, `map`, and then `bind` can be tedious every time a loop is needed. The `map_ob` function is a wrapper for `map` that unbinds the input and binds the output automatically.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggdiagram() +\n  {o <- ob_point()} +\n  {p <- ob_polar(degree(c(0, 90, 180, 270)))} +\n  connect(o, p, resect = 2) +\n  p %>%\n    map_ob(\\(pp) {\n      p2 <- pp + ob_polar(theta = degree(seq(45, 315, 90)),\n                          r = sqrt(2) / 3,\n                          color = \"orchid\")\n      list(p2,\n           connect(pp, p2, resect = 2))\n    }) \n```\n\n::: {.cell-output-display}\n![](automation_files/figure-html/fig-obmap-1.png){#fig-obmap width=672}\n:::\n:::\n\n\n\nThe `ob_map` function can output a list of different object types simultaneously.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntheta <- degree(seq(0,300, 60))\n\nggdiagram() +\n  {e6 <- ob_ellipse(\n    center = ob_polar(\n      theta = theta, \n      r = 60),\n    m1 = .5,\n    a = 8,\n    b = 4,\n    angle = theta + degree(90),\n    color = NA,\n    fill = \"orchid4\", \n    size = 4)} +\n  map_ob(e6, \\(e_i) {\n    p_i <- e_i@center\n    p_ij <- p_i + ob_polar(theta, 15)\n    c_ij <- ob_circle(\n      center = p_ij, \n      radius = 2,\n      fill = \"green4\",\n      color = NA)\n    p_ijk <- map_ob(p_ij, \\(pt_ij) {\n      ob_segment(pt_ij, pt_ij + ob_polar(theta, 4) )\n      })\n    list(p_ijk, c_ij)\n  })\n\n```\n\n::: {.cell-output-display}\n![Outputting a list of different object types in `map_ob`.](automation_files/figure-html/fig-map-1.png){#fig-map width=672}\n:::\n:::\n\n\n\nIn a more practical example, every variable in the left column is connected to every variable on the right.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 5\nclr <- viridis::viridis(k, begin = .3, end = .7)\nggdiagram() +\n  {t1 <- ob_array(ob_circle(), k = k, where = \"north\", \n                  fill = clr,\n                  color = clr)} +\n  {t2 <- ob_circle(fill = clr, color = clr)@place(\n    from = t1, \n    where = \"right\", \n    sep = 10)} +\n  map_ob(t1, \\(tt) {\n    connect(tt, t2, resect = 2, color = tt@color)\n  })\n```\n\n::: {.cell-output-display}\n![Using `map_ob` to the connect variables](automation_files/figure-html/fig-bindt1t2-1.png){#fig-bindt1t2 width=672}\n:::\n:::\n\n\n\n\n# Subsetting objects\n\nThe `[` operator can subset ggdiagram objects created with `ob_*` functions. Object `p` has 2 points in  it. To select the first point only:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np[1]\n#> S3<ggdiagram::ob_point/ggdiagram::xy/ggdiagram::shape/ggdiagram::has_style/S7_object>\n#> @ x: num 1\n#> @ y: num 0\n#> Other props: alpha, color, fill, shape, size, stroke, auto_label,\n#>              bounding_box, centroid, length, r, theta, style,\n#>              tibble, xy, geom, label, place, aesthetics\n```\n:::\n\n\n\n\nThe strategic use of subsetting can make otherwise repetitive tasks much less tedious. In @fig-c12 we connect a ring of 12 circles with one command rather than 12.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntheta <- degree(seq(0,330,30))\nclr <- hsv(theta@degree / 360, s = .4, v = .6)\nggdiagram() +\n  {c12 <- ob_circle(\n    center = ob_polar(theta, r = 6),\n    fill = clr,\n    color = NA)} +\n  connect(c12, c12[c(2:12, 1)], \n          resect = 2, \n          color = clr) \n```\n\n::: {.cell-output-display}\n![A ring of connected circles.](automation_files/figure-html/fig-c12-1.png){#fig-c12 width=672}\n:::\n:::\n\n\n\nSubsetting can be used for assignment in ggdiagram objects. For example, in @fig-subsetting, the first of four points is changed from (1,5) to (0,0)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- ob_point(x = 1:4, \n              y = 2:5)\np[1] <- ob_point(0,0, color = \"firebrick\", size = 5)\n\nggplot() + \n  coord_equal() +\n  p \n```\n\n::: {.cell-output-display}\n![Subsetting objects](automation_files/figure-html/fig-subsetting-1.png){#fig-subsetting width=384}\n:::\n:::\n\n\n\nIn @fig-path, there are  8 variables with 13 arrows connecting them. Rather than making a separate connection for each arrow, subsetting allows us to make all 13 connections with a single `connect` command. Using subsetting to assign variables within a `for` loop allows for placing the variables programmatically. If more or fewer variables are desired, setting `k` to another value, will create *k* variables and 2*k*&nbsp;&minus;&nbsp;3 connections.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Number of variables\nk <- 8L\n\n# Make k variables\nx <- ob_rectangle(ob_point(rep(0, k), rep(0, k)),\n                  label = ob_label(\n                    label = paste0(\"*X*~\", 1:k, \"~\"),\n                    vjust = .6,\n                    size = 20,\n                    family = \"Roboto Condensed\"\n                  ))\n\n\n\n# Place even variables to the right and \n# odd variables below the previous variables\nfor (i in 2:k) {\n  x[i] <- place(x[i], x[i - 1], ifelse((i %% 2) == 0, \"right\", \"below\"))\n}\n\n# Plot\nggdiagram() + \n  x +\n  # paths between variables ahead by 1 and by 2\n  connect(x[c(seq(1,k - 1), seq(1, k - 2))], \n          x[c(seq(2,k),     seq(3, k))],\n          resect = 2)\n```\n\n::: {.cell-output-display}\n![A model with 8 variables and 13 causal paths](automation_files/figure-html/fig-path-1.png){#fig-path width=672}\n:::\n:::\n",
    "supporting": [
      "automation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}