{
  "hash": "fdb421f4bd05d4fef8b965bad2d77d8b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Segments\"\nformat: \n  html:\n    toc: true\nvignette: >\n  %\\VignetteIndexEntry{segments}\n  %\\VignetteEngine{quarto::html}\n  %\\VignetteEncoding{UTF-8}\n---\n\n\n\n\n\n# Setup\n\n## Packages\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggdiagram)\nlibrary(ggplot2)\nlibrary(dplyr)\n#> \n#> Attaching package: 'dplyr'\n#> The following objects are masked from 'package:stats':\n#> \n#>     filter, lag\n#> The following objects are masked from 'package:base':\n#> \n#>     intersect, setdiff, setequal, union\nlibrary(ggtext)\nlibrary(ggarrow)\nlibrary(arrowheadr)\n\n```\n:::\n\n\n\n## Base Plot\n\nTo avoid repetitive code, we make a base plot:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nmy_font <- \"Roboto Condensed\"\nmy_font_size <- 20\nmy_point_size <- 2\nmy_arrowhead <- arrowheadr::arrow_head_deltoid(d = 2.3, n = 100)\n\n# my_colors <- viridis::viridis(2, begin = .25, end = .5)\nmy_colors <- c(\"#3B528B\", \"#21908C\")\n\ntheme_set(\n  theme_minimal(\n    base_size = my_font_size, \n    base_family = my_font) +\n    theme(axis.title.y = element_text(\n      angle = 0,\n      vjust = 0.5)))\n\nbp <- ggdiagram(\n  font_family = my_font,\n  font_size = my_font_size,\n  point_size = my_point_size,\n  linewidth = .5,\n  theme_function = theme_minimal,\n  axis.title.x =  element_text(face = \"italic\"),\n  axis.title.y = element_text(\n    face = \"italic\",\n    angle = 0,\n    hjust = .5,\n    vjust = .5)) +\n  scale_x_continuous(\n    labels = signs_centered,\n    limits = c(-4, 4)) +\n  scale_y_continuous(\n    labels = signs::signs,\n    limits = c(-4, 4))\n\n```\n:::\n\n\n\n# Specifying a segment\n\nA segment is a portion of a line between two points.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- ob_point(-3, -1)\np2 <- ob_point(3, 3)\ns1 <- ob_segment(p1, p2)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + s1 + p1 + p2\n```\n\n::: {.cell-output-display}\n![Plotting a segment and its endpoints](segments_files/figure-html/fig-s1-1.png){#fig-s1 width=672}\n:::\n:::\n\n\n\n# Styling a segment\n\nThe primary options for styling a segment are alpha, color, linetype, and linewidth. However, it can take any style from `ggarrow::geom_arrow_segment`\n\nIf you are not sure which properties can be set, you an see them in the `@aesthetics@style` slot.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns1@aesthetics@style\n#>  [1] \"alpha\"            \"arrow_head\"       \"arrow_fins\"       \"arrowhead_length\"\n#>  [5] \"color\"            \"length_head\"      \"length_fins\"      \"lineend\"         \n#>  [9] \"linejoin\"         \"linewidth\"        \"linewidth_fins\"   \"linewidth_head\"  \n#> [13] \"linetype\"         \"resect\"           \"resect_fins\"      \"resect_head\"     \n#> [17] \"stroke_color\"     \"stroke_width\"\n```\n:::\n\n\n\n\nStyles can be specified when the segment is created.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns2 <- ob_segment(p1, p2, color = \"green4\")\nbp + s2\n```\n\n::: {.cell-output-display}\n![](segments_files/figure-html/segcolor-1.png){width=672}\n:::\n:::\n\n\n\nStyles can be modified after the segment is created:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns2@linewidth <- 3\nbp + s2\n```\n\n::: {.cell-output-display}\n![](segments_files/figure-html/seglinewidth-1.png){width=672}\n:::\n:::\n\n\n\nThe `as.geom` function passes style arguments to the `ggarrow::geom_arrow_segment` function without modifying the segment's style property:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp +\n  as.geom(s1, color = \"red4\")\n```\n\n::: {.cell-output-display}\n![Make s1 appear red temporarily using `as.geom` function](segments_files/figure-html/fig-asgeom-1.png){#fig-asgeom width=672}\n:::\n:::\n\n\n\nAs an alternative, the `geom` property is a function that calls `as.geom`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + s1@geom(color = \"blue3\")\n```\n\n::: {.cell-output-display}\n![Make s1 appear red temporarily via the `geom` property](segments_files/figure-html/fig-geom-1.png){#fig-geom width=672}\n:::\n:::\n\n\n\nTo verify that s1 has not changed its color:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + s1\n```\n\n::: {.cell-output-display}\n![The `s1 object has not changed](segments_files/figure-html/fig-verify-1.png){#fig-verify width=672}\n:::\n:::\n\n\n\nA \"pipe-friendly\" way to modify any ggdiagram object is to use S7's `set_props` function, which has been re-exported to ggdiagram for the sake of convenience. Like `as.geom`, this function does not modify `s1`, but unlike `as.geom`, `set_props` can be used to save a new object with the specified modifications by assigning it to a new variable. That is, `as.geom` creates a ggplot2 geom, whereas `set_props` will create a modified a ggdiagram object (or any other S7 class).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp +\n  s1 |>\n    set_props(color = \"red\")\n```\n\n::: {.cell-output-display}\n![](segments_files/figure-html/setprops-1.png){width=672}\n:::\n:::\n\n\n\n# Features of a segment\n\n## Distance between points\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns1@distance\n#> [1] 7.211103\n```\n:::\n\n\n\nAlternately:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistance(s1)\n#> [1] 7.211103\n```\n:::\n\n\n\n\n## Line passing through the segment\n\nThe line that passes through the segment contains information about the segment, such as its slope, intercept, or angle.\n\nTo access the line that passes between both points:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns1@line\n#> S3<ggdiagram::ob_line/ggdiagram::shape/ggdiagram::has_style/S7_object>\n#> @ slope     : num 0.667\n#> @ intercept : num 1\n#> @ xintercept: num -1.5\ns1@line@slope\n#> [1] 0.6666667\ns1@line@intercept\n#> [1] 1\ns1@line@angle\n#> 34Â°\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nbp +\n  s1@line |> set_props(color = \"royalblue4\") +\n  s1@midpoint(position = c(0, 1))@label(\n    polar_just = ob_polar(s1@line@angle + degree(90), 1.5),\n    plot_point = TRUE) +\n  ob_label(c(equation(s1@line),\n             paste0(\"Distance = \",\n                    round(s1@distance, 2))),\n           center = midpoint(s1),\n           vjust = c(-.2, 1.1),\n           angle = s1@line@angle)\n```\n\n::: {.cell-output-display}\n![Line passing through segment](segments_files/figure-html/fig-line-1.png){#fig-line width=672}\n:::\n:::\n\n\n\n\n## Midpoints\n\nBy default, the `midpoint` function's `position` argument is .5, which finds the point halfway between the point of a segment:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns1@midpoint()\n#> S3<ggdiagram::ob_point/ggdiagram::xy/ggdiagram::shape/ggdiagram::has_style/S7_object>\n#> @ x: num 0\n#> @ y: num 1\n#> Other props: alpha, color, fill, shape, size, stroke, auto_label,\n#>              bounding_box, centroid, length, r, theta, style,\n#>              tibble, xy, geom, label, place, aesthetics\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nbp +\n  s1 +\n  s1@midpoint()@label(\"Midpoint\", hjust = 0, vjust = 1) +\n  s1@midpoint(c(0, .5, 1))@label(\n    plot_point = TRUE,\n    hjust = 1,\n    vjust = 0)\n```\n\n::: {.cell-output-display}\n![Midpoint of a segment](segments_files/figure-html/fig-midpoint-1.png){#fig-midpoint width=672}\n:::\n:::\n\n\n\n\nTo find the midpoint 25% of the distance between the endpoints of segment:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns1@midpoint(position = .25)\n#> S3<ggdiagram::ob_point/ggdiagram::xy/ggdiagram::shape/ggdiagram::has_style/S7_object>\n#> @ x: num -1.5\n#> @ y: num 0\n#> Other props: alpha, color, fill, shape, size, stroke, auto_label,\n#>              bounding_box, centroid, length, r, theta, style,\n#>              tibble, xy, geom, label, place, aesthetics\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nbp +\n  s1 +\n  {p25 <- s1@midpoint(.25)} +\n  p25@label(\n    label = c(\n      p25@auto_label,\n      \"Midpoint a quarter the<br>way between endpoints\"\n    ),\n    vjust = c(0, 1),\n    hjust = c(1, 0)\n  ) +\n  s1@midpoint(c(0, 1))@label(plot_point = TRUE,\n                             hjust = 1,\n                             vjust = 0)\n```\n\n::: {.cell-output-display}\n![Midpoint](segments_files/figure-html/fig-midpoint25-1.png){#fig-midpoint25 width=672}\n:::\n:::\n\n\n\nMultiple midpoints can be specified:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp +\n  s1 +\n    s1@midpoint(seq(0, 1, .2))\n```\n\n::: {.cell-output-display}\n![Selecting multiple midpoints](segments_files/figure-html/fig-multiplemidpoints-1.png){#fig-multiplemidpoints width=672}\n:::\n:::\n\n\n\nA quick way to get the endpoints of a segment is to specify \"midpoints\" at positions 0 and 1:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp +\n  s1 +\n  s1@midpoint(c(0, 1))\n```\n\n::: {.cell-output-display}\n![Selecting a segment's endpoints via the `midpoint` property.](segments_files/figure-html/fig-endpoints-1.png){#fig-endpoints width=672}\n:::\n:::\n\n\n\n# Segment chains\n\nIf a point object with multiple points is placed in the `p1` slot but the `p2` slot is left empty, a series of segments chained together will be created.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp +\n  ob_segment(\n    ob_point(x = c(-4, -2, -1, 2, 4),\n             y = c(-2, 1, -2, 3, -3)))\n```\n\n::: {.cell-output-display}\n![Chained segments](segments_files/figure-html/fig-chain-1.png){#fig-chain width=672}\n:::\n:::\n",
    "supporting": [
      "segments_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}