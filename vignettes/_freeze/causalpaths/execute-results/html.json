{
  "hash": "98e8c3749070219797fe4bf6b3b40ee8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Path Diagrams\"\nformat: \n  html:\n    toc: true\n    html-math-method: katex\nvignette: >\n  %\\VignetteIndexEntry{pathdiagrams}\n  %\\VignetteEngine{quarto::html}\n  %\\VignetteEncoding{UTF-8}\nbibliography: references.json\ncsl: apa.csl\n---\n\n\n\n\n\n# Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(ggdiagram)\nlibrary(tibble)\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(ggarrow)\n```\n:::\n\n\n\n# Path diagrams\n\nStructural equation models are often displayed with path diagrams. The visual vocabulary of path diagrams is fairly simple. As seen in @fig-objecttypes, an observed variable is a square or rectangle, and a latent variable is a circle or ellipse. Often omitted for clarity, means and intercepts are constants that can be depicted with triangles.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggdiagram(font_family = my_font, font_size = 16) +\n  {lv <- ob_circle(label = \"Latent<br>Variable\")} +\n  {r <- ob_rectangle(width = sqrt(pi),\n                  height = sqrt(pi),\n                  label = \"Observed<br>Variable\") |>\n    place(lv, \"right\", .5)} +\n  {i <- ob_circle(n = 3, \n               radius = 1.25, \n               label = \"Mean/<br>Intercept\") |> \n    place(r, \"right\", .3) + ob_point(0, -.25)} \n\n```\n\n::: {.cell-output-display}\n![Elements of a path diagram](causalpaths_files/figure-html/fig-objecttypes-1.png){#fig-objecttypes width=672}\n:::\n:::\n\n\n\nIn @fig-pathtype, two types of relationships are depicted. A single-headed arrow indicates a direct causal influence. A curved double-headed arrow indicates a correlation between two variables but does not specify the causal nature of the relationship.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggdiagram(font_family = my_font, font_size = 16) +\n  {this <- ob_circle(label = ob_label(\"This\", size = 40))} +\n  {that <- ob_circle(label = ob_label(\"That\", size = 40)) |>\n    place(this, \"right\")} +\n  connect(this, that, label = \"Causes\", resect = 2) +\n  {A <- this |> \n    place(this, \"below\")} +\n  {B <- that |> \n    place(that, \"below\")} +\n  ob_covariance(A, B, label = ob_label(\"Correlates with\", vjust = 0), arrowhead_length = 7) \n\n```\n\n::: {.cell-output-display}\n![Relationships in a path diagram](causalpaths_files/figure-html/fig-pathtype-1.png){#fig-pathtype width=70%}\n:::\n:::\n\n\n\n## Path Models for Regression\n\nA regression model can be stated very simply: *X* predicts *Y*. Most of the time, this relationship can be stated with a simplified path diagram like @fig-simpleregression.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nobserved <- redefault(\n  ob_ellipse, \n  m1 = 15)\nlb_observed <- redefault(\n  ob_label, \n  size = 48, \n  nudge_y = -.15, \n  fill = NA)\ndirect <- redefault(\n  connect, \n  resect = 2)\nlb_direct <- redefault(\n  ob_label, \n  angle = 0, \n  position = .47)\n\nggdiagram(font_family = my_font, font_size = 16) + \n  {X <- observed(label = lb_observed(\"X\"))} +\n  {Y <- observed(label = lb_observed(\"Y\")) |> \n    place(X,where = \"right\")} +\n  direct(X,Y)\n```\n\n::: {.cell-output-display}\n![Simplified path diagram of a regression model](causalpaths_files/figure-html/fig-simpleregression-1.png){#fig-simpleregression width=240}\n:::\n:::\n\n\n\nThis simple statement skips a large number of details, which can be filled in. The predictor, *X* is a random variable with an unknown distribution *F~X~*. It has a mean of *μ~X~* and a standard deviation of *σ~X~*.\n\n$$X\\sim F_X(x; \\mu_X,\\sigma^2_X)$$\n\nRegression takes *X* and subjects it to a linear transformation to create the variable *Ŷ*:\n\n$$\\hat{Y}=b_0+b_1X$$ The regression coefficients *b~0~* and *b~1~* are known as the *intercept* and *slope*, respectively. *Ŷ* is the predicted value of *Y*, given *X*.\n\nThe prediction error *e* is the difference between the actual value of *Y* and its predicted value *Ŷ*:\n\n$$e=Y-\\hat{Y}$$\n\nThe prediction error is assumed to be normally distributed with a standard deviation of *σ~e~*, which is known as the *standard error of the estimate*:\n\n$$e\\sim \\mathcal{N}(0,\\sigma^2_e)$$ Putting it all together:\n\n$$Y=\\underbrace{b_0+b_1X}_{\\hat{Y}}+e$$\n\nAll of this can be communicated succinctly with the path diagram in @fig-fullregression.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nln_color <- \"gray40\"\nlb_color <- \"gray20\"\n\n# Observed variable, label, and variance\nobserved <- redefault(ob_ellipse,\n                      a = .6,\n                      m1 = 10,\n                      color = ln_color)\n\nlb_observed <- redefault(ob_label,\n                         size = 40,\n                         nudge_y = -.07,\n                         color = lb_color)\n\nvar_observed <- redefault(ob_variance,\n                          bend = -25, \n                          looseness = 1.5,\n                          color = ln_color)\n\n\n\n# Error variable, label, and variance\n\nerror <- redefault(ob_circle, color = ln_color, radius = .5)\n\n\nlb_error <- redefault(ob_label, \n                      size = 18, \n                      color = lb_color)\n\nvar_error <- redefault(ob_variance, \n                       looseness = 1.8,\n                       theta = degree(60),\n                       where = \"east\",\n                       color = ln_color)\n\ncovariance <- redefault(\n  ob_covariance,\n  color = ln_color,\n  bend = 45,\n  linewidth = .5,\n  arrowhead_length = 7,\n  looseness = 1.2\n)\n\n# Direct Effect and label\ndirect <- redefault(connect, resect = 2, color = ln_color)\n\nlb_direct <- redefault(\n  ob_label,\n  size = 16,\n  color = lb_color,\n  angle = 0,\n  vjust = .5,\n  position = .46\n)\n\nggdiagram(font_family = my_font, font_size = 16) +\n  # Predictor Variable\n  {X <- observed(label = lb_observed(\"*X*\"))} +\n  # Predicted Value\n  {Yhat <- observed(label = lb_observed(\"*Ŷ*\")) |> \n    place(X, \"right\", sep = 2)} +\n  # Outcome Variable\n  {Y <- observed(\n    label = lb_observed(\"*Y*\")) |> \n    place(Yhat, \"right\", sep = .75)} +\n  # Error\n  {e <- error(label = lb_observed(\"*e*\", nudge_y = 0)) |> \n    place(Y, \"right\", sep = .75)} +\n  # Error Variances and labels\n  {sigma_x <- var_observed(X, where = \"west\")} +\n  {sigma_e <- var_error(e, where = \"east\")} +\n  ob_latex(tex = c(\n    r\"(\\text{\\emph{σ}}^{\\text{2}}_{\\mkern-1.5mu\\text{\\emph{X}}})\", \n    r\"(\\text{\\emph{σ}}^{\\text{2}}_{\\mkern-1.5mu\\text{\\emph{e}}})\"), \n    color = lb_color,\n    center = bind(c(sigma_x, sigma_e))@midpoint(), \n    width = .4, \n    family = my_font) +\n  # Mean / Intercept\n  {i <- ob_intercept(\n    center = ob_polar(theta = degree(60), \n                      distance(X@center,Yhat@center)) + \n      ob_point(0,-.2),\n    width = 1.2,\n    radius = unit(2, \"pt\"),\n    fill = NA, \n    linewidth = .5,\n    color = ln_color, \n    label = lb_observed(1, size = 30, nudge_y = 0))} +\n  # Direct paths\n  direct(X, Yhat, label = lb_direct(\"*b*~1~\")) + \n  direct(i, X,  label = lb_direct(\"*&mu;~X~*\")) +\n  direct(i, Yhat, label = lb_direct(\"*b*~0~\")) +\n  direct(Yhat,Y) +\n  direct(e, Y)\n\n```\n\n::: {.cell-output-display}\n![Full path diagram of a regression model](causalpaths_files/figure-html/fig-fullregression-1.png){#fig-fullregression width=100%}\n:::\n:::\n\n\n\n## Path Diagrams for Path Analysis\n\nPath diagrams were created by Sewall Wright [-@wrightRelativeImportanceHeredity1920] to display path analyses---interconnected regression models with sequences of direct and indirect relationships among variables.\n\nFor example, these two regression equations combined make up a causal system that shows how variables *X*~1~--*X*~4~ interrelate.\n\n$$\n\\begin{aligned}\nX_3&=b_{13}X_1+b_{23}X_2+e_3\\\\\nX_4&=b_{14}X_1+b_{24}X_2+b_{34}X_3+e_4\n\\end{aligned}\n$$\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n\n\nggdiagram(font_family = my_font, font_size = 16) + \n  {x1 <- observed() \n   x2 <- observed() |> \n    place(x1, \"below\", sep = 2.25) \n   x3 <- observed() |> \n    place(midpoint(x1@point_at(\"east\"),\n                   x2@point_at(\"east\")), \n          \"right\") \n   x4 <- observed() |> \n    place(x3, \"right\", sep = 1.5)\n   x <- bind(c(x1, x2, x3, x4))} +\n  lb_observed(paste0(\"*X*~\",1:4,\"~\"), x@center) + \n  {pred <-    bind(c(x2, x1, x3, x1, x2))\n   outcome <- bind(c(x3, x3, x4, x4, x4))\n   direct(pred,outcome, \n          label = lb_direct(\n            label = c(\"*b*~23~\",\n                      \"*b*~13~\",\n                      \"*b*~34~\",\n                      \"*b*~14~\",\n                      \"*b*~24~\")))} +\n  {endogenous <- bind(c(x3,x4))\n   e <- error(label = lb_error(paste0(\"*e*~\", 3:4, \"~\"))) |> \n    place(from = endogenous, \n          where = c(\"left\", \"right\"),\n          sep = .5)} + \n  direct(e, endogenous) +\n  covariance(x2@point_at(\"west\"), \n             x1@point_at(\"west\"),\n             label = lb_direct(\"*r*~12~\", position = .5))\n```\n\n::: {.cell-output-display}\n![A path diagram of a path analysis model](causalpaths_files/figure-html/fig-pathanalysis-1.png){#fig-pathanalysis width=768}\n:::\n:::\n\n\n\n\n## Path Diagrams for Exploratory Factor Analysis\n\nExploratory factor analysis (EFA) assumes that observed variables intercorrelate because there is a smaller number of latent variables influence multiple observed variables. In @fig-efa, there are 6 observed variables *x* that intercorrelate because 2 latent factors *f* act as common causes.\n\nEFA will find the loadings from latent to observed variables that best account for the observed correlations among variables. Some portion of the observed variables is independent of the latent factors. These independent influences can be thought of as uniquenesses *u*. Thus, the structural model is:\n\n$$\nx=\\Lambda f+u\n$$ where *x* is the vector observed variables, *f* is the vector of latent factors, *u* is the vector of latent uniquenesses, and Λ is the matrix of loadings that quantify the strength of the effects of *f* on *x*.\n\nThe observed variables *x*, latent factors *f*, and uniquenesses *u* each have their own covariance matrices:\n\n$$\n\\begin{aligned}\n\\Sigma&=\\text{cov}(x)\\\\\n\\Phi&=\\text{cov}(f)\\\\\n\\Theta&=\\text{cov}(u)\n\\end{aligned}\n$$\n\nThe model-implied covariance matrix for the observed variables is a function of the loading matrix Λ and the covariance matrices Φ and Θ:\n\n$$\n\\begin{aligned}\n\\hat{\\Sigma}&=\\Lambda\\Phi\\Lambda'+\\Theta\\\\\n&=\\begin{bmatrix}\n\\lambda_{11} & \\lambda_{21}\\\\\n\\lambda_{12} & \\lambda_{22}\\\\\n\\lambda_{13} & \\lambda_{23}\\\\\n\\lambda_{14} & \\lambda_{24}\\\\\n\\lambda_{15} & \\lambda_{25}\\\\\n\\lambda_{16} & \\lambda_{26}\\\\\n\\end{bmatrix}\\begin{bmatrix}\\phi_{11} & \\phi_{12}\\\\ \\phi_{12} & \\phi_{22}\\end{bmatrix}\\begin{bmatrix}\n\\lambda_{11} & \\lambda_{21}\\\\\n\\lambda_{12} & \\lambda_{22}\\\\\n\\lambda_{13} & \\lambda_{23}\\\\\n\\lambda_{14} & \\lambda_{24}\\\\\n\\lambda_{15} & \\lambda_{25}\\\\\n\\lambda_{16} & \\lambda_{26}\\\\\n\\end{bmatrix}'+\\begin{bmatrix}\n\\theta_{11} & 0 & 0 & 0 & 0 & 0\\\\ \n0 & \\theta_{22} & 0 & 0 & 0 & 0\\\\\n0 & 0 & \\theta_{33} & 0 & 0 & 0\\\\\n0 & 0 & 0 & \\theta_{44} & 0 & 0\\\\\n0 & 0 & 0 & 0 & \\theta_{55} & 0\\\\\n0 & 0 & 0 & 0 & 0 & \\theta_{66}\n\\end{bmatrix}\n\\end{aligned}\n$$\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nmy_fills <- viridis::viridis(n = 3, begin = .3, end = .6) |> \n  class_color() |> \n  set_props(saturation = .6, brightness = .5) |> \n  c()\n\nggdiagram(font_family = my_font, font_size = 16) +\n  {x <- ob_array(ob_ellipse(m1 = 8, \n                               color = NA,\n                               fill = my_fills[2]), \n                    k = 6, \n                    sep = .25)} +\n  ob_label(label = paste0(\"*X*~\",1:6, \"~\"),\n           center = x@center,\n           size = 20,\n           fill = NA,\n           nudge_y = -.1,\n           color = \"white\") +\n  {f1 <- ob_circle(radius = x[1:2]@bounding_box@width / 2, \n                   fill = my_fills[1],\n                   color = NA,\n                   label = ob_label(\n                     \"*f*~1~\", \n                     size = 48,\n                     nudge_y = -.2,\n                     fill = NA, \n                     color = \"white\")) |> \n    place(from = midpoint(x[1], x[2]), \n          where = \"above\", \n          sep = x[1:4]@bounding_box@width)} +\n  {f2 <- ob_circle(radius = x[5:6]@bounding_box@width / 2, \n                   fill = my_fills[3],\n                   color = NA,\n                   label = ob_label(\n                     \"*f*~2~\", \n                     size = 48,\n                     nudge_y = -.2,\n                     fill = NA, \n                     color = \"white\")) |> \n    place(midpoint(x[5], x[6]), \n          where = \"above\", \n          sep = x[1:4]@bounding_box@width)} +\n  {f1x <- connect(f1, \n                  x@point_at(\"top\"), \n                  resect = 2, \n                  color = my_fills[1])} + \n  {f2x <- connect(f2, \n                  x@point_at(\"top\"), \n                  resect = 2, \n                  color = my_fills[3])} +\n  {a <- intersection(f1@tangent_at(45), f2@tangent_at(135))\n   ob_arc(center = a, \n          radius = distance(a, f1@point_at(45)), \n          start = (f1@point_at(45) - a)@theta, \n          end = (f2@point_at(135) - a)@theta,\n          color = my_fills[2],\n          resect = 2, \n          linewidth = .5,\n          arrowhead_length = 7,\n          arrow_head = arrowheadr::arrow_head_deltoid(),\n          arrow_fins = arrowheadr::arrow_head_deltoid(),\n          label = ob_label(\"&phi;~12~\",\n                           color = my_fills[2],\n                           vjust = .5,\n                           size = 14))} +\n  {ob_label(paste0(\"*&lambda;*~2\", 1:6, \"~\"), \n            intersection(f1x[6] + ob_point(1.2,0), f2x), \n            size = 14,\n            label.padding = margin(),\n            color = my_fills[3])} +\n  {ob_label(paste0(\"*&lambda;*~1\", 1:6, \"~\"), \n            intersection(f2x[1] + ob_point(-1.2,0), f1x), \n            size = 14,\n            label.padding = margin(t = 2, l = 2),\n            color = my_fills[1])} +\n  ob_variance(\n    x = f1,\n    color = my_fills[1],\n    label = ob_label(\"&phi;~11~\", color = my_fills[1], size = 14)\n  ) +\n  ob_variance(\n    x = f2,\n    color = my_fills[3],\n    label = ob_label(\"&phi;~22~\", color = my_fills[3], size = 14)\n  ) +\n  {u <- ob_circle(\n    radius = .75,\n    color = NA,\n    fill = my_fills[2],\n    alpha = .5,\n    label = ob_label(\n      paste0(\"*u*~\", 1:6, \"~\"),\n      fill = NA,\n      color = \"white\",\n      size = 14\n    )\n  )@place(x, \"below\", sep = 1.2)} +\n  connect(u, x, color = my_fills[2], resect = 2) +\n  ob_variance(\n    u,\n    where = \"south\",\n    color = my_fills[2],\n    theta = 65,\n    looseness = 2.3,\n    label = ob_label(\n      paste0(\"*&theta;*~\", 1:6 * 11, \"~\"),\n      color = my_fills[2],\n      label.margin = margin(),\n      size = 12\n    )\n  )\n  \n```\n\n::: {.cell-output-display}\n![Exploratory Factor Analysis with Two Latent Factors and Six Observed Variables](causalpaths_files/figure-html/fig-efa-1.png){#fig-efa width=624}\n:::\n:::\n\n\n\n## Path Diagrams for Principal Components Analysis\n\nPrincipal components analysis (PCA) is similar to exploratory factor analysis (EFA) in that it finds latent factors from covariances among observed variables. The underlying model of PCA differs from EFA in that the indicators are *formative* rather than *reflective*. Because the principal components are fully determined by the observed variables, they have no error term. That is, they act as weighted summaries of the observed variables. In general, PCA creates latent variables that better summarize the observed data, and EFA creates latent variables that better approximate the underlying structure of the data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggdiagram(font_family = my_font) +\n  # observed variables\n  {o <- ob_ellipse(m1 = 10, a = .6, color = NA) |>\n      ob_array(5, sep = .2, fill = class_color(my_fills[2])@lighten(seq(.6, .9, length.out = 5)))} +\n  # principal components\n  {pc <- ob_circle(fill = my_fills[c(1,3)], color = NA) |> \n    place(o[c(2, 4)], \"above\", 2)} +\n  # direct effects from o to pc\n  map(\n    unbind(pc), \\(pci) {\n      connect(x = o@point_at(\"north\"), \n              y = pci, \n              color = pci@fill,\n              resect = 2)@geom()\n    }\n  ) +\n  # covariances among observed variables\n  map(1:4, \\(i) {\n    offset <- c(-1.5, -.5, .5, 1.5) * .11\n    ob_covariance(\n      x = o[seq(i + 1, 5)]@point_at(\"south\") + \n        ob_point(offset[seq(1, 5 - i)], 0),\n      y = o[i]@point_at(\"south\") + \n        ob_point(-offset[seq(1, 5 - i)], 0),\n      bend = 45,\n      looseness = 1.4,\n      linewidth = .5, \n      arrowhead_length = 6,\n      color = my_fills[2]\n    )@geom()\n  }) + \n  # Labels\n  ob_label(\"Formative<br>Indicators\", size = 16, fill = NA) |> \n    place(o@bounding_box@east, sep = .8) + \n  ob_label(\"Principal<br>Components\", size = 24, fill = NA) |> \n    place(pc@bounding_box@east, sep = 1.3) +\n  # Invisible point to prevent label from clipping\n  ob_point(o@bounding_box@east@x + 1.2, 1, color = \"white\")\n\n```\n\n::: {.cell-output-display}\n![A path diagram for a principal components analysis model](causalpaths_files/figure-html/fig-pca-1.png){#fig-pca width=672}\n:::\n:::\n\n\n\n## Path Diagrams for Confirmatory Factor Analysis\n\n@fig-latent3 shows the primary ingredients of a latent variable model. *Latent variables* are not observed directly but are inferred from the correlations among observed variables. Latent variables are displayed as circles or ellipses. Their variances are depicted as curved double-headed arrows that circle back to the same latent variable. The observed variables from which latent variables are inferred are called *indicator variables*. The direct effects from a latent variable to its indicators are called *loadings*. The variability in indicator variables that is not explained by latent variables are explained by latent *residuals* (AKA *errors*). Each residual has its own variance. In some path diagrams, residual variances are affixed directly to observed variables, and the residual variables are omitted.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggdiagram(font_family = my_font, font_size = 16) +\n  # Place a latent variable at the top\n  {l1 <- ob_circle(radius = 2)} +\n  # Place an array of observed variables below the circle\n  {o3 <- ob_ellipse(m1 = 9) |> \n    place(from = l1, \n          where = \"below\", \n          sep = 2) |> \n    ob_array(\n      k = 3,\n      where = 0,\n      sep = .4)} +\n  # Connect the latent to the observed variables at the north anchor point\n  {l1_o3 <- connect(l1, \n                    o3@point_at(\"north\"), \n                    resect = 2)} + \n  # Place error terms below each observed variable\n  {e3 <- ob_circle(radius = .75) |>\n    place(o3,\n          where = \"below\",\n          sep = .85)} +\n  # Connect the error terms to the observed variables\n  {e3_o3 <- connect(e3, o3, resect = 2)} +\n  # latent variance1\n  {v_l1 <- ob_variance(l1, where = \"north\")} +\n  # label(1, v_l1@midpoint()) + \n  {v_e3 <- ob_variance(\n    e3,\n    where = \"south\",\n    looseness = 1.4,\n    resect = unit(3, \"pt\"),\n    arrowhead_length = unit(7, \"pt\"), \n    arrow_head = arrowheadr::arrow_head_deltoid(2.4),\n    arrow_fins = arrowheadr::arrow_head_deltoid(2.4))} +\n  {lb_indicator <- ob_label(\"Indicator<br>Variables\", \n                            color = \"black\") |>\n    place(o3[1]@point_at(\"west\"), \"west\", sep = 1.2)} + \n  ob_point(-5, 0, color = \"white\") +\n  ob_label(\"Loadings\", \n           lb_indicator@center %|-% midpoint(l1, o3@bounding_box)) + \n  ob_label(\"Residuals\", \n           lb_indicator@center %|-% e3@bounding_box@center) + \n  ob_label(\"Latent<br>Variable\", lb_indicator@center %|-% l1) + \n  ob_label(\"Latent<br>Variance\", \n           lb_indicator@center %|-% l1@normal_at(\n             \"north\", \n             distance = .5)) + \n  ob_label(\"Residual<br>Variances\", \n           lb_indicator@center %|-% e3[1]@normal_at(\n             \"south\", \n             distance = .5))\n\n```\n\n::: {.cell-output-display}\n![A latent variable with three observed indicators and three latent error terms.](causalpaths_files/figure-html/fig-latent3-1.png){#fig-latent3 width=480}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nmy_fills <- viridis::viridis(n = 3, begin = .3, end = .6) |> \n  class_color() |> \n  set_props(saturation = .6, brightness = .5) |> \n  c()\n\nmy_path_color <- \"gray40\"\nmy_resect <- 1\nbroad <- c(\"Gv\", \"Gf\", \"Gc\")\nmy_arrowhead <- arrowheadr::arrow_head_deltoid(2.5)\n\ng2broad <- c(Gv = .84, Gf = .95, Gc = .80)\n\nbroad2indicator <- list(Gv = c(.78, .84, .91),\n                        Gf = c(.88, .81, .74),\n                        Gc = c(.74, .91, .93))\n\nbroad_variance <- 1 - g2broad ^ 2\n\nlatent <- redefault(ob_circle, \n                    color = NA)  \n\nlb_latent <- redefault(ob_label, \n                            size = 30, \n                            fill = NA, \n                            color = \"white\")\n\nobserved <- redefault(ob_ellipse, \n                           a = .5, \n                           b = .5, \n                           m1 = 10, \n                           # fill = my_fill,\n                           color = NA)\n\nlb_observed <- redefault(\n  ob_label, \n  size = 15, \n  fill = NA, \n  color = \"white\",\n  nudge_y = -.04)\n\ndirect <- redefault(\n  connect,\n  resect = my_resect,\n  color = my_path_color,\n  arrow_head = my_arrowhead,\n  linewidth = .5,\n  length_head = 6\n)\n\nlb_direct <- redefault(\n  ob_label,\n  size = 16,\n  color = lb_color,\n  angle = 0,\n  vjust = .5,\n  position = .46,\n  label.padding = margin(t = 3, r = 2, b = 0, l = 2, unit = \"pt\")\n)\n\nvar_latent <- redefault(\n  ob_variance, \n  theta = 40,\n  resect = my_resect,\n  color = my_path_color, \n  looseness = .9, \n  linewidth = .5,\n  arrow_head = my_arrowhead,\n  arrow_fins = my_arrowhead,\n  arrowhead_length = 6)\n\nlb_variance <- redefault(\n  lb_direct,\n  position = .5,\n  straight = TRUE\n)\n\nggdiagram(font_family = my_font, font_size = 16) +\n  {g <- latent(label = lb_latent(\"*g*\"), fill = \"gray15\")} + \n  var_latent(g, label = lb_variance(1)) +\n  {Gx <- place(g, g,where = \"below\", sep = 1.6) |> \n    ob_array(k = 3, \n                sep = 2, \n                label = lb_latent(broad, \n                                  vjust = .6),\n                fill = my_fills)} +\n  var_latent(Gx, \n             where = \"left\", \n             color = Gx@fill,\n             label = lb_variance(\n               round_probability(broad_variance, \n                                 phantom_text = \".\"),\n               color = Gx@fill)) +\n  {pGx <- direct(g, Gx, color = Gx@fill)} +\n  {lb_direct(\n    label = round_probability(g2broad, \n                              phantom_text = \".\"), \n    center = pGx@line@point_at_y(pGx[2]@midpoint(\n      position = .47)@y),\n    color = Gx@fill)} +\n  # list----\n  {vv <- map_ob(Gx, \\(b) {\n    o1 <- place(observed(fill = b@fill), \n                from = b, \n                where = \"south\",\n                sep = 1.6)\n    \n    o <- ob_array(\n      o1,\n      k = 3, \n      sep = .2,\n      fill = purrr::map_chr(c(.6, .75, .9), tinter::lighten, x = o1@fill),\n      label = lb_observed(\n        paste0(\n          b@label@label, \n          \"~\", \n          1:3, \n          \"~\")))\n    p <- direct(b, o@point_at(\"north\"), color = b@fill)\n    \n    l <- lb_direct(\n      round_probability(\n        broad2indicator[[b@label@label]],\n        phantom_text = \".\"), \n      center = p@line@point_at_y(p[2]@midpoint(position = .47)@y),\n      color = b@fill)\n    \n    v <- ob_variance(\n      o,\n      where = \"south\",\n      bend = -15,\n      looseness = 1.7,\n      resect = my_resect,\n      color = b@fill,\n      theta = 70,\n      linewidth = .5,\n      label = lb_variance(\n        round_probability(sqrt(1 - broad2indicator[[b@label@label]] ^ 2)),\n        color = b@fill),\n      arrow_head = my_arrowhead,\n      arrow_fins = my_arrowhead,\n      arrowhead_length = 6\n    )\n    c(o, p, v, l)\n  }) }\n\n```\n\n::: {.cell-output-display}\n![A structural equation path diagram](causalpaths_files/figure-html/fig-path-1.png){#fig-path width=100%}\n:::\n:::\n\n\n\nIn @fig-wedge, the same model from @fig-path is displayed showing variance proportions. The observed and latent variables all have an area of 1. The residual effects have areas proportional to their variances. The pie wedges in the endogenous latent variables and stacked bars in the observed variables have areas equal to the variance portions of their source variables.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggdiagram(font_family = my_font, font_size = 13) +\n  {g <- latent(label = lb_latent(\"*g*\"), \n               fill = \"gray15\", \n               radius = sqrt(1 / pi))} + \n  {Gx <- place(g, g,where = \"below\", sep = 1.2) |> \n    ob_array(k = 3, \n                sep = 2.4, \n                label = lb_latent(broad, \n                                  vjust = .6,\n                                  color = \"gray15\",\n                                  size = 28),\n                fill = \"gray15\")} +\n  {d_Gx <- ob_circle(\n    color = NA,\n    fill = my_fills,\n    radius = sqrt(broad_variance / pi)) |> \n    place(Gx, where = \"left\", sep = .45)} +\n  direct(d_Gx, \n          Gx, \n          color = my_fills, \n          resect = 1) +\n  {pGx <- direct(g, Gx, color = Gx@fill, resect = 1)} +\n  {lb_direct(\n    label = round_probability(g2broad,\n                              phantom_text = \".\"),\n    center = pGx@line@point_at_y(pGx[2]@midpoint(\n      position = .46)@y),\n    color = Gx@fill)} +\n  ob_wedge(center = Gx@center, \n           radius = sqrt(1 / pi),\n           start = turn(.5) + turn(broad_variance) / 2,\n           end = turn(.5) - turn(broad_variance) / 2,\n           fill = my_fills) + \n  lb_latent(broad, center = Gx@center, vjust = .6) +\n  {map(1:3, \\(i) {\n    b <- Gx[i]\n    p2 <- place(ob_point(), from = b, where = \"south\", sep = 1.2)\n    p1 <- place(ob_point(), from = p2, where = \"left\", sep = 1.1)\n    p3 <- place(ob_point(), from = p2, where = \"right\", sep = 1.1)\n    \n    p <- bind(c(p1,p2,p3))\n    \n    b_text <- b@label@label\n    \n    lb_o <- ob_label(paste0(b_text, \"~\", 1:3, \"~\"),\n                     center = p - ob_point(0,.55),\n                     color = \"white\", \n                     size = 20,\n                     fill = NA)\n    \n    \n    \n    b_p <- direct(b, p, color = my_fills[i], resect = 1)\n    \n    l_b_p <- lb_direct(\n      round_probability(broad2indicator[[b_text]], \n                        phantom_text = \".\"), \n      center = b_p@line@point_at_y(b_p[2]@midpoint(.46)@y),\n      color = my_fills[i])\n    \n    r_g <- ob_rectangle(\n      north = p, \n      fill = g@fill,\n      color = NA,\n      width = 1, \n      height = (g2broad[b_text] * broad2indicator[[b_text]]) ^ 2)\n    \n    r_broad <- ob_rectangle(\n      north = r_g@south, \n      fill = my_fills[i],\n      width = 1, \n      color = NA,\n      height = (sqrt(broad_variance[b_text]) * broad2indicator[[b_text]]) ^ 2)\n    \n    error_variance <- 1 - broad2indicator[[b_text]] ^ 2\n    \n    error_color <- class_color(my_fills[i])@lighten(.5)@color\n    \n    r_unique <- ob_rectangle(\n      north = r_broad@south, \n      fill = error_color,\n      width = 1, \n      color = NA,\n      height = error_variance)\n    \n    r <- sqrt(error_variance / pi)\n    \n    error <- ob_circle(r_unique@south - ob_point(0, r + .45), radius = r, color = NA, fill = error_color)\n    \n    error2observed <- direct(error, r_unique, resect = 1, color = error_color)\n    \n    list(r_g, \n         r_broad, \n         r_unique, \n         b_p, \n         l_b_p, \n         error, \n         error2observed, \n         lb_o) |> \n      lapply(as.geom)\n  })}\n```\n\n::: {.cell-output-display}\n![Latent variable path diagram with all variables scaled to their variance sizes. Pie wedges and stacked bars display variance proportions of source variables of the same color.](causalpaths_files/figure-html/fig-wedge-1.png){#fig-wedge width=768}\n:::\n:::\n\n\n\n@fig-hierarchy is a demonstration of how ggdiagram can be used to creating complex models with an eye to aesthetics.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nmy_serif_font <- \"Equity Text A\"\nstr_narrow <- \"Narrow Abilities\"\nstr_tests <- \"Tests\"\nstr_specifics <- \"Specifics\"\n\n# gradient fills\nblack_gradient <- grid::radialGradient(\n  colours = rev(c(\"gray50\", \"gray2\", \"gray2\")), \n  stops = c(0, .35, 1))\nblack_gradient_rev <- grid::radialGradient(\n  colours = c(\"gray50\", \"black\"))\n\nggdiagram(font_family = my_serif_font, font_size = 16) +\n  {g <- ob_circle(\n      radius = 1.33,\n      fill = NA,\n      color = NA\n    )} + \n  geom_polygon(\n    aes(x = x, y = y), \n    data = ob_circle(radius = 9)@polygon, \n    color = NA,\n    fill = black_gradient) +\n  geom_polygon(\n    aes(x = x, y = y), \n    data = g@polygon,\n    color = NA, \n    fill = black_gradient_rev) +\n  {broad_angle <- turn(seq(0, 1, length.out = 9)[-9] + 1 / 16) \n   broad_color <- hcl(\n     h = seq(0, 360 - 360 / 8, 360 / 8) + 20, \n     c = 55, \n     l = 60)\n    broad <- ob_circle(\n      color = NA, \n      fill = broad_color) |>\n      place(\n        from = g, \n        where = broad_angle, \n        sep = 1.15)} + \n  ob_label(\n        \"*g*\",\n        color = \"gray90\",\n        fill = NA,\n        size = 60,\n        vjust = .4,\n        family = my_serif_font\n      ) +\n  connect(g, broad, \n          color = broad_color, \n          resect = 1, \n          linewidth = .75, \n          length_head = 5) +\n  purrr::map(unbind(broad), \\(b) {\n    geom_polygon(\n      data = b@polygon, \n      aes(x = x, y = y), \n      fill = grid::radialGradient(\n        colours = c(tinter::lighten(b@fill, .4), \n                    tinter::lighten(b@fill, .8)), \n        stops = c(0,1)))}) +\n  ob_label(\n    c(\"Ga\", \"Gc\", \"Gf\", \"Gv\", \"Gs\", \"Gr\", \"Gl\", \"Gwm\"),\n    broad@center + ob_point(0, -.05),\n    fill = NA,\n    family = my_serif_font,\n    size = 20,\n    vjust = .55,\n    angle = broad@center@theta + degree(-90 * sign(broad@center@theta@turn)),\n    color = \"gray20\"\n  ) +\n  ob_path(\n    broad |> \n      set_props(radius = c(rep(.66, 4), rep(.59, 4))) |> \n      unbind() |> \n      purrr::map(\\(x) {\n        x@point_at(x@center@theta + degree(seq(-90, 90, 10)))\n        }),\n    color = \"gray20\",\n    alpha = 0,\n    label = ob_label(\n      c(\"Auditory\", \n        \"Knowledge\", \n        \"Fluid\", \n        \"Visual-Spatial\", \n        \"Speed\", \n        \"Fluency\", \n        \"Efficiency\", \n        \"Memory\"),\n      fill = NA,\n      family = my_serif_font,\n      vjust = 1,\n      size = 9.5,\n      spacing = 100)) +\n  ob_path(\n    broad |> \n      set_props(radius = c(rep(.59, 4), rep(.66, 4))) |> \n      unbind() |> \n      purrr::map(\\(x) {\n        x@point_at(\n          x@center@theta + degree(-180) + degree(seq(-90, 90, 10)))}),\n    label = ob_label(\n      c(\"Processing\", \n        \"Comprehension\", \n        \"Reasoning\", \n        \"Processing\", \n        \"Processing\", \n        \"Retrieval\", \n        \"Learning\", \n        \"Working\"),\n            fill = NA,\n            family = my_serif_font,\n            vjust = 1,\n      size = 9.5,\n            spacing = 100\n          ),\n          color = \"gray20\",\n          alpha = 0\n  ) +\n  {narrow <- ob_circle(\n    radius = .45, \n    fill = rep(broad@fill, each = 5)\n    ) |>\n    place(from = g, \n          where = degree(seq(0, 360 - 360/40, 360/40) + 360/80), \n          sep = 4.3)\n    \n    geom_polygon(\n      aes(x = x,\n          y = y, \n          group = group, \n          fill = fill),\n      data = narrow@polygon,\n      color = NA)} + \n  {purrr::imap(unbind(broad), \\(x, idx) {\n    connect(x, narrow[(idx - 1) * 5 + 1:5], \n            color = tinter::lighten(x@fill, .5), \n            linewidth = .5,\n            length_head = 6,\n            resect = 1) |> \n      as.geom()\n  })} +\n  {test_theta <- degree(seq(0, 360 - 360/120, 360/120) + 360/240)\n    tests <- ob_ellipse(\n      a = .18,    \n      m1 = 8,\n      angle = test_theta,\n      color = NA,\n      fill = rep(tinter::lighten(broad@fill, .2), each = 15)) |>\n      place(from = g, where = test_theta, sep = 6.2)} +\n  {specifics <- ob_circle(\n    radius = .2, \n    angle = test_theta, \n    color = NA, \n    fill = rep(tinter::lighten(broad@fill, .15), each = 15)) |> \n    place(from = g, where = test_theta, sep = 7.0)} +\n  connect(specifics, tests, \n          color = specifics@fill, \n          linewidth = .3,\n          length_head = 6, \n          resect = .5) +\n  {purrr::imap(unbind(narrow), \\(x, idx) {\n    connect(x, tests[(idx - 1) * 3 + 1:3], \n            color = tinter::lighten(x@fill, .5), \n            resect = 1, \n            linewidth = .3,\n            length_head = 6) |> \n      as.geom()\n  })} +\n  scale_fill_manual(\n    values = map(broad@fill, \n                 \\(fill) { \n                   grid::radialGradient(c(tinter::lighten(fill, .15), \n                                          tinter::lighten(fill, .4)), \n                                        stops = c(0.2, 1), \n                                        group = F)}) |> \n      `names<-`(broad@fill)) +\n  theme(legend.position = \"none\") +\n  ob_label(\n    label = rev(strsplit(str_narrow, split = character(0))[[1]]),\n    center = narrow[seq(nchar(str_narrow)) + 2]@center,\n    angle = narrow[seq(nchar(str_narrow)) + 2]@center@theta - degree(90),\n    fill = NA,\n    family = my_serif_font,\n    size = 16,\n    color = \"gray30\",\n    vjust = .55\n  ) +\n  ob_label(\n    label = strsplit(str_narrow, split = character(0))[[1]],\n    center = narrow[seq(nchar(str_narrow)) + 22]@center,\n    angle = narrow[seq(nchar(str_narrow)) + 22]@center@theta + degree(90),\n    fill = NA,\n    family = my_serif_font,\n    size = 16,\n    color = \"gray30\",\n    vjust = .55\n  ) +\n  {purrr::map(65 + c(0,15, 30, 45), \\(x) {\n    ob_label(\n      label = strsplit(str_tests, split = character(0))[[1]],\n      center = tests[seq(nchar(str_tests)) + x]@center,\n      angle = tests[seq(nchar(str_tests)) + x]@center@theta + degree(90),\n      fill = NA,\n      family = my_serif_font,\n      size = 10,\n      color = \"gray30\",\n      vjust = .57\n    )@geom()\n  })} +\n  {purrr::map(5 + c(0,15, 30, 45), \\(x) {\n    ob_label(\n      label = rev(strsplit(str_tests, split = character(0))[[1]]),\n      center = tests[seq(nchar(str_tests)) + x]@center,\n      angle = tests[seq(nchar(str_tests)) + x]@center@theta - degree(90),\n      fill = NA,\n      family = my_serif_font,\n      size = 10,\n      color = \"gray30\",\n      vjust = .57\n    )@geom()})} +\n  {purrr::map(63 + c(0,15, 30, 45), \\(x) {\n    ob_label(\n      label = strsplit(str_specifics, split = character(0))[[1]],\n      center = specifics[seq(nchar(str_specifics)) + x]@center,\n      angle = specifics[seq(nchar(str_specifics)) + x]@center@theta + degree(90),\n      fill = NA,\n      family = my_serif_font,\n      size = 9,\n      color = \"gray30\",\n      vjust = .53\n    )@geom()})} +\n  {purrr::map(3 + c(0,15, 30, 45), \\(x) {\n    ob_label(\n      label = rev(strsplit(str_specifics, split = character(0))[[1]]),\n      center = specifics[seq(nchar(str_specifics)) + x]@center,\n      angle = specifics[seq(nchar(str_specifics)) + x]@center@theta - degree(90),\n      fill = NA,\n      family = my_serif_font,\n      size = 9,\n      color = \"gray30\",\n      vjust = .53\n    )@geom()})}\n\n```\n\n::: {.cell-output-display}\n![A hierarchical model of cognitive abilities in the Cattell-Horn-Carroll tradition [@schneiderCattellHornCarrollTheoryCognitive2018]](causalpaths_files/figure-html/fig-hierarchy-1.png){#fig-hierarchy width=768}\n:::\n:::\n\n\n\n## Path Diagrams for Multilevel Models\n\nThe independence assumption of multiple regression requires that the regression errors are independent of each other. When data are clustered in some way that violates this assumption, a multilevel model can account for the within-cluster similarity of data (i.e., the intraclass correlation). Most multilevel models are displayed with equations like these:\n\n$$\n\\begin{aligned}\n\\text{Level 1}\\\\\nY_{ij}&=\\beta_{0j}+\\beta_{1j}X_{1ij}+\\beta_{2j}X_{2ij}+e_{ij}\\\\\n\\sigma_e^2&=\\text{var}\\left(e\\right)\\\\\n\\text{Level 2}\\\\\n\\beta_{0j} &= \\gamma_{00} + \\gamma_{01}W_{1j} + u_{0j}\\\\\n\\beta_{1j} &= \\gamma_{10} + \\gamma_{11}W_{1j} + u_{1j}\\\\\n\\beta_{2j} &= \\gamma_{20} + \\gamma_{21}W_{1j} + u_{2j}\\\\\n\\mathbf{\\tau} &=\\text{cov}\\left(u\\right)\\\\\n&=\\begin{bmatrix}\n\\tau_{00} & \\tau_{01} & \\tau_{02}\\\\\n\\tau_{01} & \\tau_{11} & \\tau_{12}\\\\\n\\tau_{02} & \\tau_{12} & \\tau_{22}\n\\end{bmatrix}\n\\end{aligned}\n$$\n\nHere we have an outcome (*Y*), 2 level-1 predictors (*X*~1~ and *X*~2~), and 1 level-2 predictor (*W*~1~). The random intercept (*β*~0*j*~) has as fixed component (*&gamma;*~00~&nbsp;+&nbsp;*&gamma;*~01~*W*~1*j*~) and a random component (*u*~0*j*~). The random intercept is partly predicted by the level-2 variable, *W*~1*j*~. The random slopes also have fixed and random components, as well as being predicted by the level-2 variable. The *&tau;* matrix is variance-covariance matrix of the level-2 random variables *u* (i.e., *u*~0*j*~, *u*~1*j*~, and *u*~1*j*~).\n\nThese equations specify the model unambiguously, but it is easy to lose one's way in them. It can facilitate interpretation if they equations are presented in a visual mode.\n\n@curranBuildingPathDiagrams2007 developed a set of extensions to path diagrams to incorporate random slopes and intercepts from multilevel models. Their core innovation is to treat random slopes and intercepts as latent variables that sit atop direct paths. An example of this approach is in @fig-multilevel. It displays the same information as the equations listed previously, but in terms that are easier to understand and use. \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nclr <-   class_color(\n  c(\"#976A85\",\n    \"#7385A1\",\n    \"#4E9C9B\",\n    \"#66AB7A\",\n    \"#A4AF5A\"))@darken(.3)@color\n\nclr <- c(\"#6B4B5E\", \"#515E72\", \"#376E6E\", \"#487956\", \"#747C3F\")\n\nintercept <- function(center = ob_point(),\n                      r = 1,\n                      vertex_radius = unit(.6, \"mm\"),\n                      fill = clr[1],\n                      color = NA,\n                      ...) {\n  p <- purrr::map(unbind(center), \\(cc) {\n    cc + ob_polar(degree(c(90, 210, 330)), r = r)\n  })\n  ob_polygon(p,\n             vertex_radius = vertex_radius,\n             fill = fill,\n             color = color,\n             ...)\n}\n\nobserved <- redefault(ob_ellipse, m1 = 10, color = NA)\nlb_observed <- redefault(ob_label, fill = NA, color = \"white\", size = 24)\nlb_slope <- redefault(ob_label, fill = NA, color = \"white\", size = 18)\n\nrandom_slope <- redefault(ob_circle, color = NA, radius = .5)\ntau_covariance <- redefault(ob_covariance, \n                            linewidth = .5, \n                            head_length = 4, \n                            resect = 1)\n\nggdiagram(font_family = my_font, font_size = 13) + \n  {i1 <- intercept(label = ob_label(\n    label = \"1~1~\", \n    color = \"white\",\n    fill = NA,\n    size = 24),\n    fill = clr[1])} +\n  {x1 <- observed(label = lb_observed(\"*X*~1*ij*~\"), \n                  fill = clr[2]) |>\n    place(bind(i1@segment)@midpoint()[2], \"below\", 1.5)} + \n  {x2 <- observed(label = lb_observed(\"*X*~2*ij*~\"),\n                  fill = clr[3]) |> \n    place(x1, \"below\", 1.5)} + \n  {y = observed(label = lb_observed(\"*Y*~*ij*~\"),\n                fill = clr[4]) |> \n    place(x1, \"right\", sep = 9)} + \n  {i1_y <- connect(i1, y, resect = 2, color = clr[1])} + \n  {x1_y <- connect(x1, y, resect = 2, color = clr[2])} + \n  {x2_y <- connect(x2, y, resect = 2, color = clr[3])} +\n  {latent_slope_line <- ob_line(slope = -.8, intercept = 1.3)\n  b0j <- random_slope(\n    intersection(latent_slope_line, i1_y),\n    fill = clr[1],\n    label = lb_slope(\"*&beta;*~0*j*~\")\n  )} +\n  {b1j <- random_slope(\n    intersection(latent_slope_line, x1_y),\n    fill = clr[2],\n    label = lb_slope(\"*&beta;*~1*j*~\"))} +\n  {b2j <- ob_circle(\n    intersection(latent_slope_line, x2_y),\n    radius = .5,\n    fill = clr[3],\n    color = NA,\n    label = lb_slope(\"*&beta;*~2*j*~\")\n  )} +\n  {i2 <- intercept(width = 2,\n    rotate(latent_slope_line, degree(90), origin = b0j@center)@point_at_x(b1j@center@x),\n    label = lb_observed(\"1~2~\")\n  )} +\n  {w1 <- observed(\n    center = i2@center %-|% y@center,\n    label = lb_observed(\"*W*~1*j*~\"),\n    fill = clr[5]\n  )} +\n  {b <- bind(c(b0j, b1j, b2j))\n   i2b <- connect(\n     i2,\n     b,\n     color = i2@fill,\n     resect = 2,\n     label = ob_label(\n       paste0(\"*&gamma;*~\", 0:2, \"0~\"),\n       angle = 0,\n       size = 16\n     )\n  )} +\n  {w1b <- connect(\n    w1,\n    b,\n    color = w1@fill,\n    resect = 2,\n    label = ob_label(\n      paste0(\"*&gamma;*~\", 0:2, \"1~\"),\n      angle = 0,\n      size = 16\n    )\n  )} +\n  {u <- ob_circle(\n    radius = .4,\n    color = NA,\n    fill = b@fill,\n    label = ob_label(\n      paste0(\"*u*~\", 0:2, \"*j*~\"),\n      color = \"white\",\n      fill = NA,\n      size = 14\n    )\n  ) |> place(b, \"southwest\", .5)} + \n  connect(\n    u,\n    b,\n    color = b@fill,\n    resect = 1,\n    length_head = 4,\n    linewidth = .5\n  ) +\n  tau_covariance(\n    u[2],\n    u[1],\n    color = mean_color(clr[c(1, 2)]),\n    label = ob_label(\"*&tau;*~01~\", \n                     color = mean_color(clr[c(1, 2)]))\n  ) +\n  tau_covariance(\n    u[3],\n    u[2],\n    color = mean_color(clr[c(2, 3)]),\n    label = ob_label(\"*&tau;*~12~\", color = mean_color(clr[c(2, 3)]))\n  ) +\n  tau_covariance(\n    u[3]@point_at(210),\n    u[1]@point_at(260),\n    color = mean_color(clr[c(1, 3)]),\n    label = ob_label(\"*&tau;*~02~\", color = mean_color(clr[c(1, 3)])),\n    bend = 10\n  ) + \n  ob_variance(\n    u,\n    color = u@fill,\n    \"east\",\n    linewidth = .5,\n    looseness = 1.9,\n    bend = 5,\n    arrowhead_length = 4,\n    resect = 1,\n    label = ob_label(\n      paste0(\"*&tau;*~\", 0:2, 0:2, \"~\"),\n      label.margin = margin(),\n      label.padding = margin(),\n      color = b@fill\n    ),\n    theta = 60\n  ) +\n  {e <- ob_circle(radius = .6, fill = y@fill, color = NA, label = lb_observed(\"*e~ij~*\")) |> place(y, \"right\", .9)} +\n  connect(e, y, color = y@fill, resect = 2) +\n  {e_var <- ob_variance(e, \"east\", color = e@fill, looseness = 1.7)} +\n  ob_latex(r\"(\\text{\\emph{σ}}^{\\text{2}}_{\\mkern-1.5mu\\text{\\emph{e}}})\", e_var@midpoint(), width = .45, family = \"Roboto Condensed\", filename = \"sigma_e_2\", color = e@fill)\n  \n  \n\n```\n\n::: {.cell-output-display}\n![A path diagram for a multilevel model](causalpaths_files/figure-html/fig-multilevel-1.png){#fig-multilevel width=960}\n:::\n:::\n",
    "supporting": [
      "causalpaths_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}