{
  "hash": "0c14e24e20eea398ab5068e8462e9b09",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Bézier Curves\"\nformat: \n  html:\n    toc: true\n    html-math-method: katex\nvignette: >\n  %\\VignetteIndexEntry{beziercurves}\n  %\\VignetteEngine{quarto::html}\n  %\\VignetteEncoding{UTF-8}\n---\n\n\n\n\n\n# Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggdiagram)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggtext)\nlibrary(ggarrow)\nlibrary(geomtextpath)\n\n```\n:::\n\n\n\n# Base Plot\n\nTo avoid repetitive code, we set defaults and make a base plot:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| label: baseplot\n\nmy_font <- \"Roboto Condensed\"\nmy_font_size <- 20\nmy_point_size <- 2\nmy_arrowhead <- arrowheadr::arrow_head_deltoid(2.1)\n\n# my_colors <- viridis::viridis(2, begin = .25, end = .5)\nmy_colors <- c(\"#3B528B\", \"#21908C\")\n\ntheme_set(\n  theme_minimal(\n    base_size = my_font_size,\n    base_family = my_font) +\n    theme(axis.title.y = element_text(angle = 0, vjust = 0.5)))\n\nbp <- ggdiagram(\n  font_family = my_font,\n  font_size = my_font_size,\n  point_size = my_point_size,\n  linewidth = .5,\n  theme_function = theme_minimal,\n  axis.title.x =  element_text(face = \"italic\"),\n  axis.title.y = element_text(\n    face = \"italic\",\n    angle = 0,\n    hjust = .5,\n    vjust = .5)) +\n  scale_x_continuous(labels = signs_centered,\n                     limits = c(-4, 4)) +\n  scale_y_continuous(labels = signs::signs,\n                     limits = c(-4, 4))\n\n```\n:::\n\n\n\n# Bézier curves\n\nThe `ob_bezier` function creates an object that specifies the control points for a bézier curve. A bézier curve is an extremely useful way of making elegantly curved lines between points.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  {control_points <- ob_point(\n    x = c(-4,4,4), \n    y = c(4,-4, 0))} + \n  ob_path(control_points, linetype = \"dashed\", linewidth = .25) +\n  ob_bezier(control_points)\n```\n\n::: {.cell-output-display}\n![Bézier curve with contol points](bezier_files/figure-html/fig-ob_bezier-1.png){#fig-ob_bezier width=672}\n:::\n:::\n\n\n\nI like to make a list of control points setting the start and end points first. Then I find internal control points by offsetting from the end points---adding or subtracting a point at a specified x and y distance (or angle using the `polar` function).\n\nThe `c` function creates a list of all the points, and the `bind` function binds the list into a single point object containing all the points.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# start and end of control points\np_start <- ob_point(-4,-2)\np_end <- ob_point(4, 2)\n# Offset ob_point from the endpoints\np_offset <- ob_point(5,6)\n\n# Make list of points and bind them into a single ob_point\np <- c(p_start, \n       p_start + p_offset, \n       p_end - p_offset, \n       p_end) |> \n  bind() \n\nbp + \n  ob_path(p, \n       linetype = \"dashed\", \n       color = \"gray\",\n       linewidth = .25) +\n  p + \n  ob_bezier(p, \n          label = ob_label(\"Labels can follow the path of the bézier curve.\")) \n```\n\n::: {.cell-output-display}\n![Bézier curve with contol points and label](bezier_files/figure-html/fig-bzlabel-1.png){#fig-bzlabel width=672}\n:::\n:::\n\n\n\n# Multiple bézier paths\n\nIf multiple point objects are supplied as a list (or concatenated with the `c` function), a bézier curve will be created for each point object in the list.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontrol_point_list <- c(\n      ob_point(\n        x = c(-4, -3, 4), \n        y = c(.1,  4, .1), \n        color = my_colors[1]),\n      ob_point(\n        x = c(-4, 3, 4), \n        y = c(-.1, -4, -.1), \n        color = my_colors[2] )\n      )\nbp + \n  ob_bezier(control_point_list) +\n  ob_path(control_point_list, linetype = \"dashed\", linewidth = .25) +\n  bind(control_point_list)\n```\n\n::: {.cell-output-display}\n![Multiple bézier paths](bezier_files/figure-html/fig-multbz-1.png){#fig-multbz width=672}\n:::\n:::\n",
    "supporting": [
      "bezier_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}