{
  "hash": "5341017a696f2efa8bf923a5f288cece",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Ellipses\"\nknitr:\n  opts_chunk: \n    collapse: true\n    comment: '#>'\nformat: \n  html:\n    toc: true\n    html-math-method: katex\nvignette: >\n  %\\VignetteIndexEntry{ellipses}\n  %\\VignetteEngine{quarto::html}\n  %\\VignetteEncoding{UTF-8}\n---\n\n\n\n\n\n# Setup\n\n## Packages\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggdiagram)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggtext)\nlibrary(ggarrow)\n```\n:::\n\n\n\n\n## Base Plot\n\nTo avoid repetitive code, we set defaults and make a base plot:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_font <- \"Roboto Condensed\"\nmy_font_size <- 20\nmy_point_size <- 2\nmy_arrowhead <- arrowheadr::arrow_head_deltoid(d = 2.3, n = 100)\n\n# my_colors <- viridis::viridis(2, begin = .25, end = .5)\nmy_colors <- c(\"#3B528B\", \"#21908C\")\n\ntheme_set(\n  theme_minimal(\n    base_size = my_font_size,\n    base_family = my_font) +\n    theme(axis.title.y = element_text(angle = 0, vjust = 0.5)))\n\nbp <- ggdiagram(\n  font_family = my_font,\n  font_size = my_font_size,\n  point_size = my_point_size,\n  linewidth = .5,\n  theme_function = theme_minimal,\n  axis.title.x =  element_text(face = \"italic\"),\n  axis.title.y = element_text(\n    face = \"italic\",\n    angle = 0,\n    hjust = .5,\n    vjust = .5)) +\n  scale_x_continuous(labels = signs_centered,\n                     limits = c(-4, 4)) +\n  scale_y_continuous(labels = signs::signs,\n                     limits = c(-4, 4))\n\n```\n:::\n\n\n\n\nA common way to specify an ellipse is with a center point and the two distances from the center point *c* to the horizontal and vertical edges, *a* and *b*, respectively.\n\n$$\\left(\\frac{x-c_x}{a}\\right)^2+\\left(\\frac{y-c_y}{b}\\right)^2=1$$\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 4\nb <- 3\nc1 <- ob_point(0,0)\ne1 <- ob_ellipse(c1, a = a, b = b)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nbp + \n  e1 + \n  ob_segment(c1, \n          ob_point(c(a, 0), c(0, b)), \n          color = my_colors, \n          label = ob_label(\n            label = paste0(c(\"*a* = \", \"*b* = \"), \n                           c(a, b)), \n            angle = 0)) +\n  c1\n```\n\n::: {.cell-output-display}\n![An ellipse can be specified with a center, and semi-major radii.](ellipses_files/figure-html/fig-abellipse-1.png){#fig-abellipse width=672}\n:::\n:::\n\n\n\n# Foci\n\nA circle has one focus, the center. If *a* &ne; *b*, an ellipse has two foci. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  e1 + \n  ob_label(\"*F*~1~\", e1@focus_1, plot_point = T, vjust = 1.2) +\n  ob_label(\"*F*~2~\", e1@focus_2, plot_point = T, vjust = 1.2)\n```\n\n::: {.cell-output-display}\n![An ellipse has two foci](ellipses_files/figure-html/fig-foci-1.png){#fig-foci width=672}\n:::\n:::\n\n\n\n\nFor any point *P* on the ellipse, the sum of PF~1~ and PF~2~ is 2*a* if *a* > *b* and 2*b* if *b* > *a*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeg <- degree(61.5)\n\nbp + \n  e1 + \n  ob_label(\"*F*~1~\", e1@focus_1, plot_point = T, vjust = 1.2) +\n  ob_label(\"*F*~2~\", e1@focus_2, plot_point = T, vjust = 1.2) + \n  {p <- e1@point_at(deg)} +\n  p@label(\"*P*\", polar_just = ob_polar(deg, 1.5)) +\n  ob_segment(e1@focus_1, \n          p, \n          label = paste0(\"*PF*~1~ = \",\n                         distance(e1@focus_1, p) |>\n                           round())) + \n  ob_segment(p, \n          e1@focus_2, \n          label = paste0(\"*PF*~2~ = \",\n                         distance(e1@focus_2, p) |> \n                           round())) + \n  ob_label(\"*PF*~1~ + *PF*~2~ = 2*a* = 8\", \n        center = ob_point(0,4), \n        size = 20)\n\n```\n\n::: {.cell-output-display}\n![The sum of distances from the foci is constant.](ellipses_files/figure-html/fig-focilength-1.png){#fig-focilength width=672}\n:::\n:::\n\n\n\n\n\n# Point on the ellipse at a specific angle\n\nThe `@point_at` property of an `ob_ellipse` object is a function that can find a point at a specific angle.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne1@point_at(degree(60))\n#> <ob_point>\n#> @ x: num 1.59\n#> @ y: num 2.75\n#> Other props: alpha, color, fill, shape, size, stroke, auto_label,\n#>              bounding_box, length, r, theta, style, tibble, xy,\n#>              geom, label, place, aesthetics\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndeg <- degree(60)\nbp +\n  e1 +\n  {p45 <- e1@point_at(deg)} +\n  p45@label(polar_just = ob_polar(deg, 1.5)) +\n  ob_segment(e1@center, p45) +\n  ob_arc(\n    center = e1@center,\n    radius = 1,\n    start = degree(0),\n    end = deg,\n    label = deg\n  )\n```\n\n::: {.cell-output-display}\n![Point on ellipse that is 45&deg; from the x-axis.](ellipses_files/figure-html/fig-ptheta-1.png){#fig-ptheta width=672}\n:::\n:::\n\n\n\n# Point on the ellipse using definitional parameter *t*\n\nThe angle expected by the `@point_at` function is a true angle. However, the parametric equation for ellipses has a parameter *t* that looks like an angle, but actually has no direct geometric interpretation:\n\n$$\n\\begin{aligned}\nt&=[0,2\\pi)\\\\\n(x,y) &= (a\\cos(t),b\\sin(t))\n\\end{aligned}\n$$\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntheta <- degree(seq(0, 350, 30))\n\nbp + \n  {c1 = ob_circle(radius = 3.6, color = \"gray30\")} +\n  {e1 <- ob_ellipse(a = 2.8, b = 1)} +\n  {p1 <- c1@point_at(theta)} +\n  ob_label(theta, p1, polar_just = ob_polar(theta, r = 1.5)) +\n  ob_segment(ob_point(), p1, linewidth = .2) +\n  {p2 <- e1@point_at(theta, definitional = T, color = \"dodgerblue\")} +\n  ob_segment(ob_point(), p2) + \n  ob_label(theta@degree, p2, polar_just = ob_polar(theta, r = 1.5)) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![The ellipse's definitional parameter *t* does not always line up with angles on a circle](ellipses_files/figure-html/fig-definitionalpoints-1.png){#fig-definitionalpoints width=672}\n:::\n:::\n\n\n\n\nIf the definitional point at *t* is desired:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nob_ellipse(a = 2)@point_at(degree(60), definitional = TRUE)\n#> <ob_point>\n#> @ x: num 1\n#> @ y: num 1.73\n#> Other props: alpha, color, fill, shape, size, stroke, auto_label,\n#>              bounding_box, length, r, theta, style, tibble, xy,\n#>              geom, label, place, aesthetics\n```\n:::\n\n\n\n# Tangent lines\n\nLike the `@point_at` property, the `@tangent` property is a function that will find the tangent line at a specified angle or point.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  {e1 <- ob_ellipse(a = 3, b = 2)} + \n  e1@point_at(60, color = \"firebrick4\") + \n  e1@tangent_at(60, color = \"firebrick4\")\n```\n\n::: {.cell-output-display}\n![Tangent lines on an ellipse](ellipses_files/figure-html/fig-tangent-1.png){#fig-tangent width=672}\n:::\n:::\n\n\n\nThe `@tangent` function can also take a point instead of an angle. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  e1 + \n  {p1 <- e1@point_at(60)} +\n  e1@tangent_at(p1) \n```\n\n::: {.cell-output-display}\n![](ellipses_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n\nIf the point is not on the ellipse, the tangent will be at the point's projection onto the ellipse:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  e1 + \n  {p1 <- ob_point(3, 2, color = \"firebrick4\")} +\n  e1@tangent_at(p1) + \n  projection(p1, e1)\n```\n\n::: {.cell-output-display}\n![](ellipses_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n\n# Superellipses\n\nThe standard formula for an ellipse can be altered such that the squared entities can be raised to any positive number.\n\n$$\n\\left(\\frac{x-c_x}{a}\\right)^{m_1}+\\left(\\frac{y-c_y}{b}\\right)^{m_2}=1\n$$\n\n*m*~2~ is set equal to *m*~1~ unless otherwise specified.\n\nIf *m*~1~ is 4, and *a* and *b* are equal, we can make a *squircle*, which is a square-ish circle.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  ob_ellipse(a = 3, \n          b = 3, \n          m1 = 4)\n```\n\n::: {.cell-output-display}\n![A squircle](ellipses_files/figure-html/fig-squircle-1.png){#fig-squircle width=672}\n:::\n:::\n\n\n\nIf we increase *m*~1~ to a high value like 10, we can a rectangle with pleasingly rounded corners.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp +\n  ob_ellipse(\n    a = 3,\n    b = 3,\n    m1 = 10,\n    color = NA,\n    fill = \"dodgerblue\",\n    label = ob_label(\n      label = \"My<br>Variable\",\n      fill = NA,\n      color = \"white\",\n      size = 70\n    )\n  )\n  \n```\n\n::: {.cell-output-display}\n![A superellipse can look like a rectangle with rounded corners.](ellipses_files/figure-html/fig-myvariable-1.png){#fig-myvariable width=672}\n:::\n:::\n\n\n\n# Connection Paths Among Ellipses\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  {e1 <- ob_ellipse(ob_point(-2,0), a = 2)} +\n  {e2 <- ob_ellipse(ob_point(3,2), b = 2)} +\n  connect(e1, e2, resect = 2)\n```\n\n::: {.cell-output-display}\n![Connections between ellipses](ellipses_files/figure-html/fig-connectellipse-1.png){#fig-connectellipse width=672}\n:::\n:::\n\n\n\n\n# Placing Ellipses\n\nThe `place` function will set an object at a position and distance from another object. Here we set an ellipse to the the right of `e1` (i.e., \"east\" or 0 degrees) with a separation of 2.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  {e1 <- ob_ellipse(center = ob_point(-2, 0), \n                 a = 2)} +\n  place(ob_ellipse(b = 2), \n        from = e1, \n        where = \"right\", \n        sep = 2)\n```\n\n::: {.cell-output-display}\n![Place an ellipse 2 units to the right of another ellipse.](ellipses_files/figure-html/fig-placeellipse-1.png){#fig-placeellipse width=672}\n:::\n:::\n\n\n\n\nThe `sep` parameter in the `place` function is not necessarily the shortest distance between ellipses. Instead, it is the distance between the ellipses on the segment connecting the center points. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeg <- degree(30)\n\nbp + \n  {e1 <- ob_ellipse(\n    center = ob_point(-2,-1, color =  \"dodgerblue4\"), \n    a = 2, \n    b = 1.5)} +\n  {e2 <- place(\n    ob_ellipse(\n      center = ob_point(color = \"orchid4\"),\n      b = 2),\n    from = e1, \n    where = deg, \n    sep = 2)} + \n  connect(\n    e1,\n    e2,\n    arrow_head = ggarrow::arrow_head_minimal(),\n    linetype = \"dashed\",\n    label = ob_label(2, vjust = 0)\n  ) +\n  ob_arc(e1@center, end = deg, label = deg) + \n  ob_segment(e1@center, \n             e1@point_at(deg)) + \n  ob_segment(e2@center, \n             e2@point_at(deg + degree(180))) + \n  ob_label(\"*e*~1~\", e1@center) + \n  ob_label(\"*e*~2~\", e2@center)\n\n```\n\n::: {.cell-output-display}\n![The separation distance between ellipses is along the path that connects their centers.](ellipses_files/figure-html/fig-placedistance-1.png){#fig-placedistance width=672}\n:::\n:::\n\n\n\nYou can place many ellipses at once. In @fig-manyconnections, 12 ellipses are placed around the central ellipse. Connection paths are then drawn to each ellipse.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Number of ellipses\nk <- 12\n\n# Colors\ne_fills <- hsv(\n  h = seq(0, 1 - 1 / k, length.out = k), \n  s = .4, \n  v = .6)\n\nbp + \n  {e_0 <- ob_ellipse(\n    m1 = 6,\n    label = ob_label(\n      \"*e*~0~\",\n      size = 40,\n      color = \"white\",\n      fill = \"gray20\"\n    ),\n    color = NA,\n    fill = \"gray20\"\n  )} + \n  {e_x <- place(\n    x = ob_ellipse(\n      a = .4,\n      b = .4,\n      m1 = 6,\n      label = ob_label(\n        paste0(\"*e*~\", seq(k), \"~\"),\n        color = \"white\",\n        fill = e_fills\n      ),\n      color = NA,\n      fill = e_fills\n    ),\n    from = e_0,\n    where = degree(seq(0, 360 - 360 / k, 360 / k)),\n    sep = 2\n  )} +\n  connect(e_0, e_x, resect = 2, color = e_fills) + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![Many ellipses can be placed at once.](ellipses_files/figure-html/fig-manyconnections-1.png){#fig-manyconnections width=672}\n:::\n:::\n\n\n\nLines can be placed in relation to ellipses:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  {e1 <- ob_ellipse(m1 = 4)} +\n  {l1 <- place(\n    x = ob_line(),\n    from = e1,\n    where = {deg1 <- degree(45)},\n    sep = {d = 3}\n  )} + \n  connect(\n    e1,\n    l1,\n    label = paste0(\"Distance = \", d),\n    arrow_fins = arrowheadr::arrow_head_deltoid(),\n    length_fins = 8,\n    length_head = 8,\n    resect = 1\n  ) + \n  ob_label(\n    label = l1@equation,\n    center = ob_polar(theta = deg1, \n                      r = e1@point_at(deg1)@r + d),\n    angle = l1@angle,\n    vjust = 0\n  )\n```\n\n::: {.cell-output-display}\n![A line placed 3 units and 45 degrees from a squircle.](ellipses_files/figure-html/fig-placeline-1.png){#fig-placeline width=672}\n:::\n:::\n",
    "supporting": [
      "ellipses_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}