{
  "hash": "50911cc69cec189dd2939919c1f1d5bc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Using ggdiagram\"\nvignette: >\n  %\\VignetteIndexEntry{Using ggdiagram}\n  %\\VignetteEngine{quarto::html}\n  %\\VignetteEncoding{UTF-8}\nknitr:\n  opts_chunk:\n    collapse: true\n    comment: '#>'\n    dev: \"ragg_png\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(ggdiagram)\n```\n:::\n\n\n\n\nMaking a simple diagram with a point-and-click drawing program saves time and can produce good results if handled with care. However, making a complex diagram worthy of publication can take many hours of fuss and bother.\n\nWhen I discovered [TikZ](https://tikz.dev/), I was amazed at how much better my diagrams could be. TikZ knows things about the objects it draws---like where lines and objects intersect and how far they are from each other. Instead of eyeballing where to place objects, I could tell TikZ exactly where to draw objects in relation to each other (e.g., draw a circle to the right of rectangle with 4cm of space between them). I suspect that the precision, consistency, and beauty of TikZ diagrams add to their persuasive power because readers intuit that such figures are the product of careful deliberation.\n\nBecause I mainly compute statistical models in R, getting information from R to TikZ was an intensive process, and integrating TikZ graphics with R graphics was often an exercise in frustration. Though I very much respect the labor of those who have made the TikZ ecosystem open and flexible, I never felt at ease when trying to automate TikZ or extending its capabilities. \n\nWhen the S7 package became available, it seemed that what I wanted was within my grasp: to draw diagrams with an object-oriented approach, welding the precision of TikZ with the flexibility of R. The ggdiagram package makes objects that can hold or compute various properties and can be placed directly in a ggplot2 plot. I do not imagine that ggdiagram will ever duplicate the full functionality of TikZ, but being able to make TikZ-like diagrams within R eliminates many pain points from my previous workflow and offers a world of possibilities.\n\n# First steps\n\nThe ggplot2 ecosystem already has the ability to create points, lines, and shapes, and it is ideally suited for the display of data and statistical trends. There is no reason to use ggdiagram for the tasks that ggplot2 already does fabulously well. However, once ggplot2 creates points, lines, and shapes, it is not always easy to extract information about them to create new objects. For example, if I draw a line segment from the center of an ellipse to the center of a rectangle, where does the line intersect with the ellipse and the rectangle? Where is the point midway between those intersection points? These quantities can be computed with a bit of algebra and trigonometry, but when making complex figures, such computations are tedious distractions.\n\nThe functions in ggdiagram with the `ob_` prefix (e.g,. `ob_point`, `ob_line`, and `ob_circle`) create objects using [S7](https://rconsortium.github.io/S7/), which allows the objects to hold information about the object's properties (e.g., location, color, and rotation angle) and to compute the location of its edges and points of intersection with other objects. Properties of S7 objects are extracted with the `@` operator. For example, we can create a circle with the `ob_circle` function and extract various properties:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ob_circle()\nx@radius\n#> [1] 1\nx@circumference\n#> [1] 6.283185\nx@area\n#> [1] 3.141593\nx@diameter\n#> [1] 2\n```\n:::\n\n\n\n# Simple Plots\n\nAs seen in @fig-ob, objects with the `ob_` prefix can be added to any ggplot object in the usual manner.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot\nggplot() +\n  ob_circle(radius = 1) +\n  ob_rectangle(width = 2, \n               height = 2) + \n  coord_equal() + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![Adding objects using the `ggplot` function](ggdiagram_files/figure-html/fig-ob-1.png){#fig-ob width=672}\n:::\n:::\n\n\n\nThe `ggdiagram` function calls the `ggplot` function, sets the ggplot2 theme (defaults to `theme_void`), and also sets the defaults of key geoms so that font families, font sizes, line widths, and point sizes do not have to be specified repeatedly.\n\n\nIn @fig-theta, we can locate points on a circle's circumference at any angle. The `degree` function makes it easy to compute and label angles as degrees. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntheta <- degree(c(0, 53, 90, 138, 180, 241, 270, 338))\n\nggdiagram(font_size = 18) +\n  x +\n  x@center +\n  x@point_at(theta)@label(theta)\n```\n\n::: {.cell-output-display}\n![The center of a circle and a point at an angle.](ggdiagram_files/figure-html/fig-theta-1.png){#fig-theta width=672}\n:::\n:::\n\n\n\n# Styling an object\n\nObjects in ggdiagram can be styled in any way that its underlying geom can be styled. Let's create a segment and its two endpoints.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- ob_point(-3, 2)\np2 <- ob_point(1, 5)\ns1 <- ob_segment(p1, p2)\nbp <- ggdiagram(theme_function = ggplot2::theme_minimal, \n                font_size = 18)\nbp +\n  p1 +\n  p2 + \n  s1\n```\n\n::: {.cell-output-display}\n![](ggdiagram_files/figure-html/s1-1.png){width=672}\n:::\n:::\n\n\n\n\nThe primary options for styling a segment are alpha, color, linetype, and linewidth. However, it can take any style from [`ggarrow::geom_arrow_segment`](https://teunbrand.github.io/ggarrow/reference/geom_arrow_segment.html)\n\nIf you are not sure which properties can be set, you an see them in the `@aesthetics@style` slot.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns1@aesthetics@style\n#>  [1] \"alpha\"            \"arrow_head\"       \"arrow_fins\"       \"arrowhead_length\"\n#>  [5] \"color\"            \"length_head\"      \"length_fins\"      \"lineend\"         \n#>  [9] \"linejoin\"         \"linewidth\"        \"linewidth_fins\"   \"linewidth_head\"  \n#> [13] \"linetype\"         \"resect\"           \"resect_fins\"      \"resect_head\"     \n#> [17] \"stroke_color\"     \"stroke_width\"\n```\n:::\n\n\n\n\nStyles can be specified when the object is created.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns2 <- ob_segment(p1, p2, color = \"green4\")\nbp + s2\n```\n\n::: {.cell-output-display}\n![Styling an object](ggdiagram_files/figure-html/fig-segcolor-1.png){#fig-segcolor width=672}\n:::\n:::\n\n\n\nStyles can be modified after the segment is created:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns2@linewidth <- 3\nbp + s2\n```\n\n::: {.cell-output-display}\n![Changing an object's style after it has been created.](ggdiagram_files/figure-html/fig-seglinewidth-1.png){#fig-seglinewidth width=672}\n:::\n:::\n\n\n\nThe `as.geom` function passes style arguments to the `ggarrow::geom_arrow_segment` function without modifying the segment's style property:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp +\n  as.geom(s1, color = \"red4\")\n```\n\n::: {.cell-output-display}\n![Make s1 appear red temporarily using `as.geom` function](ggdiagram_files/figure-html/fig-asgeom-1.png){#fig-asgeom width=672}\n:::\n:::\n\n\n\nAs an alternative, the `geom` property is a function that calls `as.geom`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + s1@geom(color = \"blue3\")\n```\n\n::: {.cell-output-display}\n![Make s1 appear red temporarily via the `geom` property](ggdiagram_files/figure-html/fig-geom-1.png){#fig-geom width=672}\n:::\n:::\n\n\n\nTo verify that s1 has not changed its color:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + s1\n```\n\n::: {.cell-output-display}\n![The `s1` object has not changed](ggdiagram_files/figure-html/fig-verify-1.png){#fig-verify width=672}\n:::\n:::\n\n\n\nA \"pipe-friendly\" way to modify any ggdiagram object is to use S7's `set_props` function, which has been re-exported to ggdiagram for the sake of convenience. Like `as.geom`, this function does not modify `s1`, but unlike `as.geom`, `set_props` can be used to save a new object with the specified modifications by assigning it to a new variable. That is, `as.geom` creates a ggplot2 geom, whereas `set_props` will create a modified a ggdiagram object (or any other S7 class).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp +\n  s1 |> set_props(color = \"red\")\n```\n\n::: {.cell-output-display}\n![Setting styles in a ggplot pipeline.](ggdiagram_files/figure-html/fig-setprops-1.png){#fig-setprops width=672}\n:::\n:::\n\n\n\n\n# Placing Objects in Relation to Other Objects\n\nThe `place` function will place an object a specified distance and direction from another object. Here we place a 1 &times; 1 rectangle below unit circle `x` such that the separation between them is .5 units. The `connect` function draws an arrow between them, with 2mm of space resected.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- ob_circle()\ny <- ob_rectangle() %>% \n  place(from = x, where = \"below\", sep = .5)\n\nggdiagram() +\n  x +\n  y + \n  connect(x,y, resect = 2)\n```\n\n::: {.cell-output-display}\n![](ggdiagram_files/figure-html/fig-place-1.png){#fig-place width=672}\n:::\n:::\n\n\n\nThe `where` parameter can be specified with \n\n- Direction words like *left*, *right*, *above*, *top*, *below*, *bottom*, *above left*, *top right*, *below right*, *bottom left*, etc.\n- Cardinal points like *north*, *south*, *east*, *west*, *northeast*, *southwest*,  *north-northeast*, *west-southwest*, etc.\n- Degrees using the `degree` function (e.g., `degree(21)`)\n- Radians using the `radian` function (e.g., `radian(pi)`)\n- Turns using the `turn` function (e.g., `turn(1/5)`)\n\n# Object Arrays\n\nSometimes it is useful to make arrays of objects. The `ob_array` function makes `k` copies of an object and arranges them along a direct and separates them by a specified amount. By default, the array is arranged horizontally, centered on the original object, separated by 1 unit. Here we make an array of 5 circles.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggdiagram(font_size = 18) +\n  ob_circle() %>% \n  ob_array(k = 5, label = 1:5) \n```\n\n::: {.cell-output-display}\n![A horizontal array of 5 unit circles, separated by 1 unit](ggdiagram_files/figure-html/fig-array1-1.png){#fig-array1 width=672}\n:::\n:::\n\n\n\nArrays can go in any direction:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggdiagram(font_size = 18) +\n  ob_rectangle() %>% \n  ob_array(k = 6, \n           sep = .2, \n           where = degree(-45),\n           label = 1:6) \n```\n\n::: {.cell-output-display}\n![An array of 6 rectangles, separated by .2 units along an angle of negative 45 degrees](ggdiagram_files/figure-html/fig-array2-1.png){#fig-array2 width=672}\n:::\n:::\n\n\n\nArrays can be anchored at any point on the rectangle that contains the array. For example, here we create a vertical array of 3 ellipses anchored at the bottom of the bounding box that contains the array.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggdiagram(font_size = 18, theme_function = ggplot2::theme_minimal) +\n  ob_ellipse(a = 2) %>% \n  ob_array(k = 3, \n           sep = .2, \n           where = \"north\",\n           label = 1:3,\n           anchor = \"south\") +\n  ob_point()\n```\n\n::: {.cell-output-display}\n![A vertical array of 3 ellipses anchored at the bottom](ggdiagram_files/figure-html/fig-array3-1.png){#fig-array3 width=672}\n:::\n:::\n\n\n\n\n# Building Plots Sequentially in a ggplot2 Pipeline\n\nOften we want to build a diagram in which newer objects depend on previously specified objects. To assign a variable in the middle of a ggplot2 workflow, we can enclose an assignment statement in curly braces `{}`.\n\n@fig-indicators makes use of a curly braces to create:\n\n* Latent variable *A* as a circle with radius 2, \n* Observed variables *A*~1~--*A*~3~ 3 units below *A* \n* Loading paths (connecting arrows) from the latent *A* to observed variables *A*~1~--*A*~3~\n* Error variance paths for each observed variable.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Loadings\nloadings <- c(.86, .79, .90)\n\nggdiagram(font_size = 16) +\n  # Latent variable\n  {A <- ob_circle(radius = 2, label = ob_label(\"A\", size = 96))} +\n  # Observed variables (array of 3 superellipses below A)\n  {A_3 <- ob_ellipse(m1 = 20) %>%\n    place(from = A, where = \"below\", sep = 3) %>%\n    ob_array(\n      k = 3,\n      sep = .5,\n      label = ob_label(\n        label = paste0(\"A~\", 1:3, \"~\"),\n        size = 32,\n        vjust = .6\n      )\n    )} +\n  # Observed variable loadings\n  connect(\n    from = A,\n    to = A_3,\n    resect = 2,\n    label = ob_label(round_probability(loadings), \n                     angle = 0)\n  ) +\n  # Error variances\n  ob_variance(\n    A_3,\n    where = \"south\",\n    bend = -15,\n    label = ob_label(round_probability(sqrt(1 - loadings ^ 2)))\n  ) \n```\n\n::: {.cell-output-display}\n![A latent variable with 3 observed indicators](ggdiagram_files/figure-html/fig-indicators-1.png){#fig-indicators width=528}\n:::\n:::\n",
    "supporting": [
      "ggdiagram_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}