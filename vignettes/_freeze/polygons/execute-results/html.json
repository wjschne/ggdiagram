{
  "hash": "f369143ff349b16f0309ae00d9066d3d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Polygons\"\nformat: \n  html:\n    toc: true\n    html-math-method: katex\nvignette: >\n  %\\VignetteIndexEntry{polygons}\n  %\\VignetteEngine{quarto::html}\n  %\\VignetteEncoding{UTF-8}\n---\n\n\n\n\n\n# Setup\n\n## Packages\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggdiagram)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggtext)\nlibrary(ggarrow)\nlibrary(arrowheadr)\n\n```\n:::\n\n\n\n## Base Plot\n\nTo avoid repetitive code, we make a base plot:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nmy_font <- \"Roboto Condensed\"\nmy_font_size <- 20\nmy_point_size <- 2\nmy_arrowhead <- arrowheadr::arrow_head_deltoid(d = 2.3, n = 100)\n\n# my_colors <- viridis::viridis(2, begin = .25, end = .5)\nmy_colors <- c(\"#3B528B\", \"#21908C\")\n\ntheme_set(\n  theme_minimal(\n    base_size = my_font_size,\n    base_family = my_font) +\n    theme(axis.title.y = element_text(angle = 0, vjust = 0.5)))\n\nbp <- ggdiagram(\n  font_family = my_font,\n  font_size = my_font_size,\n  point_size = my_point_size,\n  linewidth = .5,\n  theme_function = theme_minimal,\n  axis.title.x =  element_text(face = \"italic\"),\n  axis.title.y = element_text(\n    face = \"italic\",\n    angle = 0,\n    hjust = .5,\n    vjust = .5)) +\n  scale_x_continuous(labels = signs_centered,\n                     limits = c(-4, 4)) +\n  scale_y_continuous(labels = signs::signs,\n                     limits = c(-4, 4))\n\n```\n:::\n\n\n\n# Polygons\n\nThe `ob_polygon` function creates an object that connects points to make a polygon.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- ob_point(x = c(-4,-3, 4,  3, -1), \n           y = c( 0, 4, 3, -3, -4))\nbp + \n  ob_polygon(p, fill = \"dodgerblue3\")\n```\n\n::: {.cell-output-display}\n![Plotting a path.](polygons_files/figure-html/fig-path-1.png){#fig-path width=672}\n:::\n:::\n\n\n\n\n# Polygon Labels\n\nThe label of a `ob_polygon` object is placed, by default, at the centroid of the polygon. The centroid is the point whose x coordinate is the average of all the x coordinates of the polygon's points and whose y coordinate is likewise the average of all the point's y coordinates.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp +\n  ob_polygon(\n    p = p,\n    label = ob_label(\n      \"My<br>Polygon\",\n      size = 20,\n      color = \"white\"\n    ),\n    fill = \"dodgerblue4\"\n  )\n\n```\n\n::: {.cell-output-display}\n![A path with a curved label](polygons_files/figure-html/fig-polygonlabel-1.png){#fig-polygonlabel width=672}\n:::\n:::\n\n\n\n# Connecting polygons\n\nConnections between polygons are arrows that emanate from and point towards the polygons' centroids.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  {p1 <- ob_polygon(.5 * p - ob_point(1.9,1.9), \n              fill = \"dodgerblue4\")} + \n  {p2 <- ob_polygon(.5 * p + ob_point(1.9, 1.9), \n              fill = \"orchid4\")} + \n  connect(p1, p2, \n          resect = 1, \n          label = \".45\")\n```\n\n::: {.cell-output-display}\n![Arrow between two polygons](polygons_files/figure-html/fig-polygonconnect-1.png){#fig-polygonconnect width=672}\n:::\n:::\n\n\n\n# Rounding polygons\n\nThe `@radius` property controls the radius of the rounded vertices. It must be of length 1. It can be given in as a `ggplot2::unit` or as a numeric value. If numeric, it is understood as a proportion of the plot area width.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  ob_polygon(\n    p, \n    radius = unit(5, \"mm\"),\n    fill = \"dodgerblue4\")\n```\n\n::: {.cell-output-display}\n![A polygon with rounded vertices](polygons_files/figure-html/fig-roundedpolygon-1.png){#fig-roundedpolygon width=672}\n:::\n:::\n\n\n\n# Regular Polygons (ngons)\n\nAn `ob_ngon` (regular polygon) can be be created by specifying the center point, the number of sides, and the radius (the distance from the center to a vertex). \n\nIn @fig-regon, many regular polygons are displayed concentrically.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 10\nbp +\n  ob_ngon(\n    n = n:1 + 2,\n    radius = 4 * seq(1, .1, length.out = n) ^ .7,\n    fill = viridis::viridis(n = n, begin = .2, end = .8) %>%\n      tinter::lighten(.6),\n    color = \"white\",\n    linewidth = 1,\n    angle = 90\n  )\n```\n\n::: {.cell-output-display}\n![Regular polygons](polygons_files/figure-html/fig-regon-1.png){#fig-regon width=672}\n:::\n:::\n\n\n\nAlternately, instead of the `radius`, the `ob_ngon` object can be specified with either the `side_length` or the `apothem` (the distance from the center to a side's midpoint). \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  {ng <- ob_ngon(n = 8, \n                 radius = 4, \n                 angle = degree(22.5),\n                 fill = \"dodgerblue4\")} +\n  ob_segment(\n    ng@center,\n    ng@vertices[1],\n    color = \"white\",\n    label = ob_label(paste0(\"Radius = \", ng@radius), \n                     vjust = 1.2, \n                     fill = NA,\n                     family = my_font)\n  ) +\n  ob_segment(\n    ng@center,\n    ng@segments[1]@midpoint(),\n    color = \"white\",\n    label = ob_label(paste0(\"Apothem = \", round(ng@apothem, 2)), \n                     vjust = -.2, \n                     fill = NA,\n                     family = my_font)\n  ) + \n  ob_label(paste0(\"Side = \", \n                  round(ng@side_length, 2)), \n           ng@segments[1]@midpoint(), \n           angle = ng@segments[1]@line@angle, \n           vjust = -0.2,\n           family = my_font) \n```\n\n::: {.cell-output-display}\n![The `ob_ngon` object can be specificied with the `radius`, `side_length`, or `apothem`.](polygons_files/figure-html/fig-ngon-1.png){#fig-ngon width=672}\n:::\n:::\n\n\n\n\n\n# Reuleaux Polygons\n\nStart with a regular polygon with an odd number of sides. For each pair of adjacent vertices, draw an arc with its center on the vertex of the opposite side. Amazingly, if you roll a Reuleaux polygon, its height is constant. This means that a Reuleaux polygon can roll smoothly. In @fig-reuleaux3, a Reuleaux triangle is made with the `ob_reuleaux` function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nth <- 275\nggdiagram() +\n  {x <- ob_reuleaux(\n    n = 3,\n    fill = NA,\n    angle = 45\n  )} \n\n```\n\n::: {.cell-output-display}\n![A Reuleaux triangle](polygons_files/figure-html/fig-reuleaux3-1.png){#fig-reuleaux3 width=672}\n:::\n:::\n\n\n\n\nIn @fig-reuleaux we draw 6 Reuleaux polygons with sides ranging from 3 to 13.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggdiagram() +\n  ob_reuleaux(\n    n = seq(13, 3, -2),\n    radius = seq(2, 1, -.2),\n    fill = viridis::viridis(\n      n = 6, \n      begin = .2, \n      end = .8) %>% \n      tinter::lighten(.6),\n    color = \"white\",\n    linewidth = 1\n  )\n\n```\n\n::: {.cell-output-display}\n![Six Reuleaux polygons arranged concentrically](polygons_files/figure-html/fig-reuleaux-1.png){#fig-reuleaux width=672}\n:::\n:::\n\n\n\n\n\nA true Reuleaux polygon with an even number of sides is not possible, but it is possible to draw even-sided figures that resemble Reuleaux polygons (@fig-reuleaux4). These figures do not have same height as they roll.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggdiagram() +\n  ob_reuleaux(\n    n = 4,\n    fill = NA,\n    angle = 45\n  ) \n\n```\n\n::: {.cell-output-display}\n![A Reuleaux-like square](polygons_files/figure-html/fig-reuleaux4-1.png){#fig-reuleaux4 width=672}\n:::\n:::\n\n\n\nSpecifying `n = 2` will create a symmetric lens, which is also not a Reuleaux polygon.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggdiagram() +\n  ob_reuleaux(\n    n = 2,\n    fill = NA\n  ) \n\n```\n\n::: {.cell-output-display}\n![A symmetric lens](polygons_files/figure-html/fig-reuleaux2-1.png){#fig-reuleaux2 width=672}\n:::\n:::\n",
    "supporting": [
      "polygons_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}