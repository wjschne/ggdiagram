{
  "hash": "b39210504816c6dbc8114d48d38a8f2e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Circles\"\nknitr:\n  opts_chunk: \n    collapse: true\n    comment: '#>'\nformat: \n  html:\n    toc: true\nvignette: >\n  %\\VignetteIndexEntry{circles}\n  %\\VignetteEngine{quarto::html}\n  %\\VignetteEncoding{UTF-8}\n---\n\n\n\n\n\n# Setup\n\n## Packages\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggdiagram)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggtext)\nlibrary(ggarrow)\n```\n:::\n\n\n\n\n## Base Plot\n\nTo avoid repetitive code, we make a base plot:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| label: baseplot\n\nmy_font <- \"Roboto Condensed\"\nmy_font_size <- 20\nmy_point_size <- 2\nmy_arrowhead <- arrowheadr::arrow_head_deltoid(d = 2.3, n = 100)\n\n# my_colors <- viridis::viridis(2, begin = .25, end = .5)\nmy_colors <- c(\"#3B528B\", \"#21908C\")\n\ntheme_set(\n  theme_minimal(\n    base_size = my_font_size,\n    base_family = my_font) +\n    theme(axis.title.y = element_text(angle = 0, vjust = 0.5)))\n\nbp <- ggdiagram(\n  font_family = my_font,\n  font_size = my_font_size,\n  point_size = my_point_size,\n  linewidth = .5,\n  theme_function = theme_minimal,\n  axis.title.x =  element_text(face = \"italic\"),\n  axis.title.y = element_text(\n    face = \"italic\",\n    angle = 0,\n    hjust = .5,\n    vjust = .5)) +\n  scale_x_continuous(labels = signs_centered,\n                     limits = c(-4, 4)) +\n  scale_y_continuous(labels = signs::signs,\n                     limits = c(-4, 4))\n\n```\n:::\n\n\n\n# Specifying a Circle\n\nCircles can be specified by a point at the circle's center (*x*~0~, *y*~0~) and a radius *r* (the distance from the center to the circle's edge).\n\n$$\n(x-x_0)^2+(y-y_0)^2=r^2\n$$\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- ob_point(0,0)\nr <- 3\nc1 <-  ob_circle(center = p, radius = r)\nc1\n#> <ob_circle>\n#> @ center: <ob_point>\n#>  @ x: num 0\n#>  @ y: num 0\n#> @ radius: num 3\n#> Other props: label, alpha, color, fill, linewidth, linetype, n,\n#>              area, bounding_box, circumference, diameter, length,\n#>              polygon, style, tibble, geom, angle_at, normal_at,\n#>              tangent_at, place, point_at, aesthetics\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nbp +\n  c1 +\n  ob_segment(\n    c1@center,\n    c1@point_at(0),\n    color = my_colors[1],\n    label = ob_label(paste0(\"*r* = \", c1@radius), angle = 0, vjust = 0)\n  ) +\n  c1@center@label(vjust = 1.2, plot_point = T) \n\n```\n\n::: {.cell-output-display}\n![A circle can be specified with a center and a radius,](circles_files/figure-html/fig-circle-1.png){#fig-circle width=672}\n:::\n:::\n\n\n\n\n## Point on the circle at a specific angle\n\nIt is common to need one or more points at a specific angle.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc1@point_at(degree(60))\n#> <ob_point>\n#> @ x: num 1.5\n#> @ y: num 2.6\n#> Other props: alpha, color, fill, shape, size, stroke, auto_label,\n#>              bounding_box, length, r, theta, style, tibble, xy,\n#>              geom, label, place, aesthetics\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndeg <- degree(60)\n\nbp + \n  c1 +\n  {p45 <- c1@point_at(deg)} +\n  p45@label(polar_just = ob_polar(deg, 1.5)) +\n  ob_segment(c1@center, p45) +\n  ob_arc(radius = 1, start = degree(0), end = deg, label = deg)\n```\n\n::: {.cell-output-display}\n![Point on circle that is 45&deg; from the x-axis.](circles_files/figure-html/fig-ptheta-1.png){#fig-ptheta width=672}\n:::\n:::\n\n\n\nMultiple points can be specified at once.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  c1 +\n  c1@point_at(degree(seq(0,340, 20)))\n  \n```\n\n::: {.cell-output-display}\n![Points on circle 20 degrees apart.](circles_files/figure-html/fig-pthetas-1.png){#fig-pthetas width=672}\n:::\n:::\n\n\n\nThese can be named points (e.g., north|top|above, south|bottom|below, east|right, west|left, northwest|top left|above left, southeast|bottom right|below right, north-northwest).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npositions <- c(\"top\", \"bottom\", \"left\", \"right\", \"northeast\", \"north-northeast\")\n\nbp +\n  c1 +\n  {p <- c1@point_at(positions)} +\n  ob_label(positions, p, polar_just = ob_polar(p@theta, 1.7))\n```\n\n::: {.cell-output-display}\n![The `@point_at` property can take angles or named positions](circles_files/figure-html/fig_namedpoints-1.png){width=672}\n:::\n:::\n\n\n\n\n\n# Placing circles \n\n## Placing circles next to each other\n\nThe `place` function places an object at a specified direction and distance from another object. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  {A <- ob_circle(\n    center = ob_point(-2, 0), \n    radius = 1, \n    label = ob_label(\"A\", size = 30))} + \n  place(\n    ob_circle(radius = 1.5,\n           label = ob_label(\"B\", size = 30)),\n    from = A,\n    where = \"right\",\n    sep = 1)\n```\n\n::: {.cell-output-display}\n![Place Circle B one unit to the right of Circle A](circles_files/figure-html/fig-place-1.png){#fig-place width=672}\n:::\n:::\n\n\n\nThe `where` argument can take degrees or named positions: \n\neast, right, east-northeast, northeast, top right, above right, north-northeast, north, top, above, north-northwest, northwest, top left, above left, west-northwest, west, left, west-southwest, southwest, bottom left, below left, south-southwest, south, bottom, below, south-southeast, southeast, bottom right, below right, east-southeast\n\nMultiple circles can be created at once with named directions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  {c3 <- ob_circle(ob_point(0, 0), radius = 1)} + \n  place(ob_circle(radius = .5), \n        from = c3, \n        where = c(\"northwest\", \n                  \"northeast\", \n                  \"south-southeast\", \n                  \"south-southwest\"), \n        sep = 1)\n```\n\n::: {.cell-output-display}\n![Place mutliple circles using named directions](circles_files/figure-html/fig-multplace-1.png){#fig-multplace width=672}\n:::\n:::\n\n\n\nOr with numbers (degrees):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  c3 + \n  place(ob_circle(radius = .5), \n        from = c3, \n        where = c(0, 30, -30), \n        sep = 1)\n```\n\n::: {.cell-output-display}\n![Place mutliple circles using degrees](circles_files/figure-html/fig-multdegree-1.png){#fig-multdegree width=672}\n:::\n:::\n\n\n\nWith styles:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp +\n  {c4 <- ob_circle(\n      radius = 1,\n      color = NA,\n      fill = \"gray35\")} +\n  place(\n    ob_circle(\n      color = NA,\n      fill = class_color(viridis::viridis(\n        n = 6, \n        option = \"D\"))@lighten(.7)@color\n    ),\n    from = c4,\n    where = degree(seq(0, 300, 60)),\n    sep = 1\n  ) \n```\n\n::: {.cell-output-display}\n![Place mutliple circles with styling](circles_files/figure-html/fig-style-1.png){#fig-style width=672}\n:::\n:::\n\n\n\n## Placing circles next to points and points next to circles\n\nThis works the same as placing circles next to each other. Here we create a point in the center, place six circles around it, and then place 12 points around each circle using the `map_ob` function to \"map\" objects like the `map_*` functions in the purrr package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp +\n  {p1 <- ob_point(0, 0)} +\n  {c6 <- place(\n      x = ob_circle(\n        radius = .5,\n        fill = viridis::viridis(6),\n        color = NA\n      ),\n      from = p1,\n      where = degree(seq(0, 300, 60)),\n      sep = 2\n    )} +\n  map_ob(unbind(c6),\n         \\(x) ob_point(color = x@fill) |>\n           place(\n             from = x,\n             where = degree(seq(0, 330, 30)),\n             sep = .5\n           ))\n```\n\n::: {.cell-output-display}\n![Place circles around a point, and points around each circle](circles_files/figure-html/fig-multimulti-1.png){#fig-multimulti width=672}\n:::\n:::\n\n\n\n## Placing lines next to circles\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp +\n  {c7 <- ob_circle()} +\n  place(ob_line(), c7, where = degree(45), sep = 1)\n```\n\n::: {.cell-output-display}\n![Placing a line one unit northeast of a circle](circles_files/figure-html/fig-linecircle-1.png){#fig-linecircle width=672}\n:::\n:::\n\n\n\n\n# Drawing path connectors between circles\n\nLet's make two circles and draw an arrow path between them\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  {c1 <- ob_circle(ob_point(-2, 2), radius = 1)} + \n  {c2 <- ob_circle(ob_point(1.5,-1.5), radius = 1.5)} +\n  connect(c1, c2)\n```\n\n::: {.cell-output-display}\n![Connect two circles](circles_files/figure-html/fig-connectcircles-1.png){#fig-connectcircles width=672}\n:::\n:::\n\n\n\nThat is fine, but we often need labels and styling to make scientific diagrams. For example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp +\n  {cthis <- ob_circle(\n    ob_point(-2, 2),\n    radius = 1,\n    fill = my_colors[1],\n    color = NA,\n    label = ob_label(\n      \"This\",\n      color = \"white\",\n      fill = NA,\n      size = 35\n    )\n  )} + \n  {cthat <- ob_circle(\n    ob_point(1.5, -1.5),\n    radius = 1.5,\n    fill = my_colors[2],\n    color = NA,\n    label = ob_label(\n      \"That\",\n      color = \"white\",\n      fill = NA,\n      size = 55\n    )\n  )} +\n  connect(cthis, cthat, \n       resect = 2, \n       label = ob_label(\"Causes\", size = 20, vjust = 0),\n       color = \"black\")\n```\n\n::: {.cell-output-display}\n![Connect two circles with labels and styles](circles_files/figure-html/fig-connectcirclesstyles-1.png){#fig-connectcirclesstyles width=672}\n:::\n:::\n\n\n\n# Paths between circles and lines\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbp + \n  c1 +\n  {l1 <- ob_line(slope = 2, intercept = 0)} +\n  connect(c1, l1) +\n  {c2 <- ob_circle(ob_point(2, -2))} + \n  connect(l1, c2)\n```\n\n::: {.cell-output-display}\n![Connect a circle to a line and a line to a circle](circles_files/figure-html/fig-connectcircleline-1.png){#fig-connectcircleline width=672}\n:::\n:::\n",
    "supporting": [
      "circles_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}