{
  "hash": "8c3ae4e626cb692df469a6039a7051d4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Recreating Figures form Byrne's *Elements of Euclid*\"\nformat: \n  html:\n    toc: true\n    code-fold: true\n    html-math-method: katex\n    backgroundcolor: \"#fcf3d9\"\n    mainfont: \"Libre Caslon Text\"\nvignette: >\n  %\\VignetteIndexEntry{elements}\n  %\\VignetteEngine{quarto::html}\n  %\\VignetteEncoding{UTF-8}\n---\n\n\n\nAs an exercise, I wanted to see how well ggdiagram could recreate (loosely) a selection of the classic diagrams from Oliver Byrne's (1847) *Elements of Euclid*. A beautiful, full reproduction can be seen [here](https://www.c82.net/euclid/).\n\nThe code I have written is not always the cleanest, easiest way to do things. Instead of finding the quickest way to create the figures, I imagined that I have Euclidean construction tools only: a compass and a straightedge, and I produced the points, lines and circles in the same way they are specified in the text.\n\nFrom [Common_straightedge-and-compass_constructions](https://en.wikipedia.org/wiki/Straightedge_and_compass_construction), the allowable operations are:\n\n* Creating the line through two points\n* Creating the circle that contains one point and has a center at another point\n* Creating the point at the intersection of two (non-parallel) lines \n* Creating the one point or two points in the intersection of a line and a circle (if they intersect) \n* Creating the one point or two points in the intersection of two circles (if they intersect).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggdiagram)\nlibrary(ggplot2)\nred <- \"#d42a20\"\nyellow <- \"#FAC22B\"\nblue <- \"#0C7AA5\"\nblack <- \"#000000\"\nbg <- \"#fcf3d9\"\nmy_font <- \"Libre Caslon Text\"\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  dev = \"ragg_png\",\n  dev.args = list(background = bg),\n  comment = \"#>\",\n  fig.width = 7,\n  fig.height = 7\n)\n\nggplot2::update_geom_defaults(ggforce::GeomCircle, list(linewidth = 2))\nbaseplot <- ggdiagram(\n  panel.background = element_rect(bg, color = NA),\n  plot.background = element_rect(bg, \n                                 color = NA),\n  font_family = my_font, \n  linewidth = 2, font_size = 18)\n```\n:::\n\n\n\n# Book I\n\n## Definition IX\n\nA plane rectilinear angle is the inclination of two straight lines to one another, which meet together, but are not in the same straight line.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\no <- ob_point(0, 0)\ntheta <- degree(c(0,35))\nbaseplot +\n  ob_wedge(end = theta[2],\n           radius = .6,\n           fill = yellow) +\n  ob_segment(o, ob_polar(theta, r = 1, color = c(red, blue))) \n```\n\n::: {.cell-output-display}\n![Illustration of an angle](elements_files/figure-html/fig-angle-1.png){#fig-angle width=672}\n:::\n:::\n\n\n\n## Definition X\n\nWhen one straight line standing on another straight line makes the adjacent angles equal, each of these angles is called a *right angle*, and each of these lines is said to be *perpendicular* to the other.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaseplot +\n  ob_segment(o, ob_polar(degree(c(0,90, 180)))) + \n  {a <- ob_arc(o, radius = .85, start = c(0,90), end = c(90, 180), linewidth = 3)} +\n  a@hatch(linewidth = 1) +\n  ob_rectangle(o + ob_point(0,.05), height = .1, width = .2, linewidth = 1)\n```\n\n::: {.cell-output-display}\n![Illustration of right angles](elements_files/figure-html/fig-rightangle-1.png){#fig-rightangle width=480}\n:::\n:::\n\n\n\n## Definition XV\n\nA *circle* is a plane figure, bounded by one continued line, called its *circumference* or *periphery*; and having a certain point within it, from which all straight lines drawn to its circumference are equal.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaseplot +\n  {s <- ob_segment(o, ob_polar(degree(c(135/2, 135, 290, 0, 180))),\n             color = c(black, red, yellow, blue, blue))} + \n  s@hatch(linewidth = 1) +\n  ob_circle(color = red)\n```\n\n::: {.cell-output-display}\n![A circle has a circumference line equally distant from a point.](elements_files/figure-html/fig-circle-1.png){#fig-circle width=384}\n:::\n:::\n\n\n\n## Proposition 1\n\nTo construct an equilateral triangle on a given finite straight-line.\n\nLet AB be the given finite straight-line.\n\nSo it is required to construct an equilateral triangle on the straight-line AB.\n\nLet the circle BCD with center A and radius AB have been drawn, and again let the circle ACE with center B and radius BA have been drawn. And let the straight-lines CA and CB have been joined from the point C, where the circles cut one another, to the points A and B (respectively).\n\nAnd since the point A is the center of the circle CDB, AC is equal to AB. Again, since the point B is the center of the circle CAE, BC is equal to BA. But CA was also shown (to be) equal to AB. Thus, CA and CB are each equal to AB. But things equal to the same thing are also equal to one another. Thus, CA is also equal to CB. Thus, the three (straight lines) CA, AB, and BC are equal to one another.\n\nThus, the triangle ABC is equilateral, and has been constructed on the given finite straight-line AB.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Radius\nr <- 1\n\n# Points A and B\npA <- ob_point(0, 0)\npB <- ob_polar(degree(0), r)\n\n# Circles\ncBCD <- ob_circle(pA, r, color = blue)\ncACE <- ob_circle(pB, r, color = red)\n\n# Intersection of circles to make equilateral triangle\npC <- intersection(cBCD, cACE)[1]\n\n# Points to label circles\npD <- cBCD@point_at(180)\npE <- cACE@point_at(0)\n\n# Segments AC and BC\nsAB <- ob_segment(pA, pB, color = black)\nsAC <- ob_segment(pA, pC, color = yellow)\nsBC <- ob_segment(pB, pC, color = red)\n\n# Bind segments\nsABC <- bind(c(sAB, sAC, sBC))\n\n# Hatch marks to note congruence\nhABC <- sABC@hatch(linewidth = .75) \n\n# Make point labels\nlABCDE <- ob_label(\n  LETTERS[1:5],\n  bind(c(pA, pB, pC, pD, pE)),\n  fill = bg,\n  color = c(red, blue, black, blue, red),\n  size = 18,\n  family = my_font,\n  vjust = .5,\n  label.padding = margin(4,3,0,3),\n  label.r = unit(9, units = \"pt\")\n)\n\nbaseplot +\n  sABC +\n  cBCD +\n  cACE +\n  lABCDE +\n  hABC\n```\n\n::: {.cell-output-display}\n![Make an equilateral trigangle starting with line AB.](elements_files/figure-html/fig-equilateral-1.png){#fig-equilateral width=576}\n:::\n:::\n\n\n\n## Proposition 2\n\n*To place a straight line equal to a given straight line with one end at a given point.*\n\nLet A be the given point, and BC the given straight line.\n\nIt is required to place a straight line equal to the given straight line BC with one end at the point A.\n\nJoin the straight line AB from the point A to the point B, and construct the equilateral triangle DAB on it.\n\nProduce the straight lines AE and BF in a straight line with DA and DB. Describe the circle CGH with center B and radius BC, and again, describe the circle GIJ with center D and radius DG.\n\nSince the point B is the center of the circle CGH, therefore BC equals BG. Again, since the point D is the center of the circle GKI, therefore DL equals DG.\n\nAnd in these DA equals DB, therefore the remainder AJ equals the remainder BG.\n\nBut BC was also proved equal to BG, therefore each of the straight lines AL and BC equals BG. And things which equal the same thing also equal one another, therefore AJ also equals BC.\n\nTherefore the straight line AJ equal to the given straight line BC has been placed with one end at the given point A.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npA <- ob_point(1, 2)\npB <- ob_point(0, 0)\npC <- ob_point(-2, -2)\n\nsAB <- ob_segment(pA, pB, color = red)\nsBC <- ob_segment(pB, pC)\n\nr_AB <- distance(sAB)\n\npD <- intersection(ob_circle(pA, r_AB), ob_circle(pB, r_AB))[2]\n\nsAD <- ob_segment(pA, pD, color = red)\nsBD <- ob_segment(pB, pD, color = red)\n\np_ABD <- bind(c(pA, pB, pD))\n\ncCGH <- ob_circle(pB, distance(pB, pC), color = blue)\npH <- cCGH@point_at(sAD@line@angle + degree(90))\n\npF <- cCGH@normal_at(sBD@line@angle, 1.5)\n\nsBF <- ob_segment(pB, pF, color = yellow, linetype = \"11\")\nsDF <- ob_segment(pD, pF)\n\npG <- intersection(sDF, cCGH)\n\nsBG <- ob_segment(pB, pG, color = yellow)\n\ncGIK <- ob_circle(pD, distance(pD, pG), color = red)\n\npI <- cGIK@point_at(sBD@line@angle + degree(180))\npE <- cGIK@normal_at((pA - pD)@theta, 1.5)\n\nsAE <- ob_segment(pA, pE, color = black, linetype = \"11\")\n\npK <- intersection(sAE, cGIK)\n\nsAK <- ob_segment(pA, pK, color = black)\n\np <- bind(c(pA, pB, pC, pD, pE, pF, pG, pH, pI, pK))\n\npABD <- ob_path(bind(c(pA,pD,pB, pA)), color = red, linewidth = 2)\n\nbaseplot +\n  sBC +\n  pABD +\n  bind(c(sAB, sBD, sAD))@hatch(\n    linewidth = 1, \n    height = .12) +\n  bind(c(sBC, sAK, sBG))@hatch(\n    k = 2,\n    height = .12,\n    linewidth = 1,\n    sep = .1\n  ) +\n  cCGH +\n  sBF +\n  sBG +\n  sAE +\n  sAK +\n  cGIK +\n  p@label(c(LETTERS[1:9], \"K\"), \n          fill = bg, \n          # vjust = c(rep(.55, 9), .5),\n          label.r = unit(9, units = \"pt\"),\n          label.padding = margin(4,3,1,3))\n\n```\n\n::: {.cell-output-display}\n![Make a line starting at point A the same length as line BC](elements_files/figure-html/fig-prop2-1.png){#fig-prop2 width=672}\n:::\n:::\n\n\n\n## Proposition 47\n\nLet ABC be a right-angled triangle having the angle ACB right.\n\nI say that the square on AB equals the sum of the squares on AC and BC.\n\nDescribe the square ADEB on AB, and the squares HA and FB on AC and CB. Draw AJ through A parallel to either AD or BE. K is the intersection of AB and CJ.\n\nJoin CE and AG.\n\nAngle CBG = Angle ABE. To each add angle CBA. Therefore, angle ABG = angle CBE, and because BE = AB and CB = BG, triangle ABG = triangle CBE.\n\nBecause AC is parallel to BG, and triangle ABG and rectangle BCFG share side BG, twice the area of triangle ABG is equal to the area of rectangle BCFG.\n\nBecause CJ is parallel to BE, and triangle CBE. and rectangle KJEB share side BE, twice the area of triangle CBE is equal to the area of rectangle KJEB.\n\nBecause triangle ABG = triangle CBE, twice the area of triangle ABG = twice the area of triangle CBE = area of rectangle BCFG = area of rectangle BCFG.\n\nIn the same manner it may be shown that the area of rectangle ACHI and rectangle ADJK are equal. \n\nThe sum of the area of rectangle ADJK and the area of rectangle KJEB equals the area of rectangle ADEB. Therefore, the sum of the area of rectangle ACHI and the area of rectangle BCFG equals the area of rectangle ADEB.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npA <- ob_point(0,0)\npB <- ob_point(2,0)\n\nsAB <- ob_segment(pA,pB, color = red)\n\npC <- ob_circle(sAB@midpoint(), \n                radius = distance(pA, pB) / 2)@point_at(120)\n\nsAC <- ob_segment(pA, pC, color = yellow)\nsBC <- ob_segment(pB, pC, color = blue)\n\npD <- rotate(pB, degree(-90), origin = pA)\npE <- rotate(pA, degree(90), origin = pB)\n\npF <- rotate(pB, degree(90), origin = pC)\npG <- rotate(pC, degree(-90), origin = pB)\n\npH <- rotate(pA, degree(-90), origin = pC)\npI <- rotate(pC, degree(90), origin = pA)\n\n\n\n# make copy so underlying dash is background color\nsBE <- ob_segment(pB,\n                  pE,\n                  color = red,\n                  linetype = \"11\")\n\nsBE2 <- sBE %>% set_props(color = bg, linetype = \"solid\")\n\nsCE <- ob_segment(pC, pE, color = yellow, linewidth = 1)\nsAG <- ob_segment(pA, pG, color = yellow, linewidth = 1)\nsCD <- ob_segment(pC, pD, color = blue, linewidth = 1)\nsBI <- ob_segment(pB, pI, color = blue, linewidth = 1)\n\n\nsBG <- ob_segment(pB,\n                  pG,\n                  color = blue,\n                  linetype = \"11\")\n\nsBG2 <- sBG %>% \n  set_props(color = bg, \n            linetype = \"solid\")\n\nlC <- ob_line(xintercept = pC@x)\nsDE <- ob_segment(pD, pE)\npJ <- intersection(lC, sDE)\npK <- intersection(lC, sAB)\n\nsCJ <- ob_segment(pC,\n                  pJ,\n                  color = black,\n                  linetype = \"11\")\n\nsCJ2 <- sCJ %>% \n  set_props(color = bg, \n            linetype = \"solid\")\n\n# Bind points\np <- bind(c(pA, pB, pC, pD, pE, pF, pG, pH, pI, pJ, pK))\n# points for orienting labels\np_orient <- bind(\n  c(pG, pA, pE, pB, pA, pB, pC, pA, pC, pC, nudge(pK, -.01, -.01))\n)\n# polar adjustments for labels\np_just <- ob_polar((p - p_orient)@theta , r = 1.4)\n\n\nbaseplot +\n  scale_y_continuous(expand = expansion(.2)) +\n  ob_polygon(bind(c(pB, pC, pF, pG)), fill = red, color = NA) +\n  ob_polygon(bind(c(pA, pB, pE, pD)), fill = blue, color = NA) +\n  ob_polygon(bind(c(pA, pC, pH, pI)), fill = black, color = NA) +\n  ob_polygon(bind(c(pA, pD, pJ, pK)), fill = yellow, color = NA) +\n  ob_wedge(\n    pB,\n    radius = .4,\n    start = (pC - pB)@theta,\n    end = (pA - pB)@theta,\n    fill = black,\n    color = NA\n  ) +\n  ob_wedge(\n    pB,\n    radius = .4,\n    start = (pA - pB)@theta,\n    end = (pE - pB)@theta@positive,\n    fill = yellow,\n    color = NA\n  ) +\n  ob_wedge(\n    pB,\n    radius = .4,\n    start = (pG - pB)@theta,\n    end = (pC - pB)@theta,\n    fill = yellow,\n    color = NA\n  ) +\n  sBC +\n  sAB +\n  sCE +\n  sAG +\n  sAC +\n  sCJ2 + sCJ +\n  sBE2 + sBE +\n  sBG2 + sBG +\n  ob_label(\n    c(LETTERS[seq(1, p@length)]),\n    center = p,\n    fill = NA,\n    color = black,\n    polar_just = p_just,\n    label.r = unit(9, units = \"pt\"),\n    label.padding = margin(4, 3, 1, 3)\n  )\n\n```\n\n::: {.cell-output-display}\n![Proof of the Pythagorean Theorem](elements_files/figure-html/fig-pythogorean-1.png){#fig-pythogorean width=672}\n:::\n:::\n\n\n\n\n# Book IV\n\n## Definition III\n\nA rectilinear figure is said to be inscribed in a circle, when the vertex of each angle of the figure is in the circumference of the circle.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np0 <- ob_point(0,0)\nc0 <- ob_circle(p0)\npABCD <- c0@point_at(degree(seq(0, 270, 90)))\n\nbaseplot + \n  ob_polygon(pABCD, color = red, fill = NA) +\n  ob_wedge(pABCD, start = pABCD@theta + degree(135), end = pABCD@theta + degree(225), radius = .2, fill = red) +\n  c0 \n```\n\n::: {.cell-output-display}\n![](elements_files/figure-html/fig-inscribed-1.png){#fig-inscribed width=672}\n:::\n:::\n\n\n\n\n## Definition IV\n\nA rectilinear figure is said to be circumscribed about a circle, when each of its sides is a tangent to the circle.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaseplot + \n  {ng <- ob_ngon(n = 4, fill = red, angle = 45)} +\n  ob_circle(fill = bg, color = NA, radius = ng@apothem)\n```\n\n::: {.cell-output-display}\n![](elements_files/figure-html/fig-circumscribed-1.png){#fig-circumscribed width=672}\n:::\n:::\n\n\n\n\n## Definition V\n\nA circle is said to be inscribed in a rectilinear figure, when each side of the figure is a tangent to the circle.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaseplot +\n  {ng <- ob_ngon(n = 6, fill = blue)} +\n  ob_circle(fill = bg, color = NA, radius = ng@apothem)\n\n```\n\n::: {.cell-output-display}\n![](elements_files/figure-html/fig-circleinscribed-1.png){#fig-circleinscribed width=672}\n:::\n:::\n\n\n\n\n## Definition VI\n\nA circle is said to be circumscribed about a rectilinear figure, when the circumference passes through the vertex of each angle of the figure.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Points for inner triangle\np <- ob_polar(degree(c(270, 15, 135)))\n# Circle from 3 points\nc1 <- circle_from_3_points(p)\ntangents <- c1@angle_at(p) %>% \n  c1@tangent_at()\n\ncircumscribed <- intersection(\n  tangents[c(1,1,2)], \n  tangents[c(2,3,3)]) %>% \n  ob_polygon(color = black, fill = NA)\n\nbaseplot + \n  ob_polygon(p, fill = blue, color = NA) + \n  c1 +\n  circumscribed \n  \n  \n```\n\n::: {.cell-output-display}\n![](elements_files/figure-html/fig-circumscribedtangents-1.png){#fig-circumscribedtangents width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n\nd <- 1.4\nnode <- redefault(\n  ob_circle,\n  radius = 1 / sqrt(pi),\n  fill = blue,\n  alpha = .5,\n  color = blue,\n  linewidth = 1\n)\nct <- redefault(\n  connect,\n  resect = 1,\n  color = black,\n  alpha = .3,\n  linewidth = .75,\n  length_head = 5\n)\n\ntransition <- redefault(\n  ob_rectangle,\n  height = 1,\n  width = 1,\n  color = black,\n  fill = black,\n  alpha = .3,\n  linewidth = .75\n)\nggdiagram(font_family = \"Roboto Condensed\", font_size = 20) +\n  {waiting <- node()} +\n  {critical <- node() %>% place(waiting, \"below\", d)} +\n  {s <- node() %>% place(critical, \"below\", d)\n   s1 <- node(fill = red, color = red) %>% place(s, \"left\", 0)\n   }  +\n  {s2 <- node(fill = red, color = red) %>% place(s, \"right\", 0)} +\n  {leave <- transition() %>% place(critical, \"right\", d)} + \n  {enter <- transition() %>% place(critical, \"left\", d)} + \n  {s3 <- node() %>% place(s, \"below\", d)} + \n  {e2 <- transition() %>% place(s3, \"left\", d)} +\n  {l2 <- transition() %>% place(s3, \"right\", d)} +\n  {s4 <- node() %>% place(s3, \"below\", d)} +\n  bind(c(waiting@center, \n         s4@center, \n         s2@center + ob_polar(degree(c(90, 210, 330)), .2))) %>% set_props(color = black, fill = NA_character_, size = 4, alpha = 1) +\n  bind(c(\n    ct(enter, bind(c(critical, s1))),\n    ct(critical, leave),\n    ct(s1, bind(c(leave, l2))),\n    ct(leave, s2),\n    ct(s2, bind(c(enter, e2))),\n    ct(e2, bind(c(s1, s3))),\n    ct(l2, s2),\n    ct(s3, l2)\n  )) +\n  ob_bezier(c(bind(c(waiting@point_at(\"west\"),\n                   waiting@center %-|% enter@center,\n                   enter@point_at(\"north\"))),\n              bind(c(s4@point_at(\"west\"),\n                   s4@center %-|% e2@center,\n                   e2@point_at(\"south\"))),\n              bind(c(l2@point_at(\"south\"),\n                   l2@center %|-% s4@center,\n                   s4@point_at(\"east\"))),\n              bind(c(leave@point_at(\"north\"),\n                   leave@center %|-% waiting@center,\n                   waiting@point_at(\"east\")))), \n            resect = 2, \n            arrow_head = arrowheadr::arrow_head_deltoid(2.3), \n            linewidth = .75, \n            color = black,\n            alpha = .5,length_head = 5) +\n  ob_latex(\n    \"s\",\n    ob_point() %>% place(s1, \"left\", .15),\n    color = red,\n    hjust = 1,\n    fill = NA,\n    width = .4,\n    density = 600\n  ) +\n  ob_latex(\n    \"\\\\bar{s}\",\n    ob_point() %>% place(s2, \"right\", .15),\n    color = red,\n    fill = NA,\n    hjust = 0,\n    width = .4,\n    density = 600\n  )\n```\n\n::: {.cell-output-display}\n![](elements_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "elements_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}