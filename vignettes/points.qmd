---
title: "Points"
format: 
  html:
    toc: true
vignette: >
  %\VignetteIndexEntry{points}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

```{r presetup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  dev = "ragg_png",
  comment = "#>",
  fig.width = 7,
  fig.height = 7
)
library(ggdiagram)
library(ggplot2)
library(dplyr)
library(ggtext)
library(ggarrow)
library(arrowheadr)
my_font <- "Roboto Condensed"
gdtools::register_gfont(family = my_font)
gdtools::addGFontHtmlDependency(family = my_font)
```

# Setup

## Packages

```{r setup}
library(ggdiagram)
library(ggplot2)
library(dplyr)
library(ggtext)
library(ggarrow)
library(arrowheadr)

```

## Base plot

To avoid repetitive code, we make a base plot:

```{r baseplot}
my_font <- "Roboto Condensed"
my_text_size <- 20
my_point_size <- 3
my_arrow_head <- arrowheadr::arrow_head_deltoid()
update_geom_defaults(geom = "richtext", 
                     new = list(family = my_font, 
                                size = .8 * my_text_size / ggplot2::.pt))

update_geom_defaults("point", list(size = my_point_size))

theme_set(
  theme_minimal(
    base_size = my_text_size, 
    base_family = my_font) +
    theme(axis.title.y = element_text(angle = 0, vjust = 0.5, face = "italic")))
bp <- ggplot() +
  coord_equal(xlim = c(0, 5), ylim = c(0, 5))
```

# Points

Points have x and y coordinates. 

```{r points}
p1 <- point(1, 2, color = "firebrick")
p2 <- point(3, 4, color = "royalblue3")

bp + p1 + p2
```

## Polar Coordinates

A point's x and y coordinates can be specified in polar coordinates

* `@r`: The distance from the origin to the point (i.e., the vector's magnitude)
* `@theta`: The angle (in radians) from the line on the x-axis to the line containing the vector.

```{r rtheta}
p2
p2@r
p2@theta
```


```{r fig-polar}
#| code-fold: true
#| fig-cap: "Polar Coordinates"
#| fig-width: 7
#| fig-height: 7
a <- arc(end = p2@theta, color = "royalblue3")
s <- segment(point(), p2 = p2)

ggplot() +
  coord_equal(xlim = c(-p2@r, p2@r), 
              ylim = c(-p2@r, p2@r)) +
  scale_x_continuous(breaks = -10:10, 
                     minor_breaks = NULL, 
                     labels = WJSmisc::signs_centered) +
  scale_y_continuous(breaks = -10:10, 
                     minor_breaks = NULL, 
                     labels = signs::signs) +
  circle(radius = p2@r) +
  p2@label(plot_point = TRUE, 
           polar_just = polar(p2@theta, r = 1.5)) +
  s + 
  s@label("*r* = " + round(distance(s), 2)) +
  a +
  a@label("&theta; = " + degree(p2@theta), 
          angle = a@midpoint()@theta)
```


A point can be created with polar coordinates

```{r polar}
polar(r = 5, theta = degree(60))
```

If the angle is numeric instead of an angle, it is assumed to be in radians. 

```{r radian}
polar(r = 1, theta = pi)@theta
```


# Convert to tibble

This will extract any styles that have been set.

```{r get_tibble}
get_tibble(point(1,2, 
                 color = "red", 
                 shape = 16))
```

As a convenience, the tibble associated with the point object can be accessed with the `@tibble` property.

```{r at_tibble}
point(1:5,2, 
      color = "blue", 
      shape = 1:5)@tibble
```


# Methods

## Arithmetic

Points can be added and subtracted:

```{r addition}
p1 <- point(2, 3)
p2 <- point(2, 1)
p3 <- p1 + p2
p3
p3 - p2
```

Points can be scaled with constants

```{r scaling}
p2 * 2
p3 / 4
```

The x and y coordinates can be scaled separately with other points:

```{r point_scaling}
p1 / p3
p1 * p3
```


# Distance

The distance between two points:

```{r point_distance}
distance(p1, p2)
```

The shortest distance from a point to a line:

```{r point_line_distance}
l1 <- line(slope = 1, 
           intercept = 2)
distance(p1, l1)
```

The shortest distance from a point to a circle's edge:

```{r point_circle_distance}

c1 <- circle(center = point(2, 2), radius = 2)
p1 <- c1@center + polar(
  r = c1@radius * 1, 
  theta = degree(115), 
  color = "royalblue3")

p2 <- c1@center + polar(
  r = c1@radius * 2, 
  theta = degree(45), 
  color = "firebrick4")

p3 <- c1@center + polar(
  r = c1@radius * .3, 
  theta = degree(190), 
  color = "orchid4")


# p1 is on circle, so its distance is 0
distance(p1, c1)
# p2 is outside the circle
distance(p2, c1)
# p3 is inside the circle
distance(p3, c1)
```

```{r fig-pointcircle}
#| code-fold: true
#| fig-cap: "Point to Circle Distances"
#| fig-width: 7
#| fig-height: 7
pts <- bind_shape(c(p1, p2, p3))
intersect_c1_p2 <- c1@point_at_theta((p2 - c1@center)@theta)
seg_c1_p2 <- segment(
  p2, 
  intersect_c1_p2, 
  arrowhead_length = 7,
  arrow_head = my_arrow_head,
  arrow_fins = my_arrow_head,
  resect = unit(5, "pt"))

intersect_c1_p3 <- c1@point_at_theta((p3 - c1@center)@theta)
seg_c1_p3 <- seg_c1_p2
seg_c1_p3@p1 <- p3
seg_c1_p3@p2 <- intersect_c1_p3
seg_c1_p3@color = p3@color

p_labels <- paste0("P<sub>",1:3, "</sub>")


bp +
  c1 +
  p1@label(label = p_labels[1], 
           plot_point = T,
           polar_just = polar(
             theta = (p1 - c1@center)@theta,
             r = 1.3)) +
  seg_c1_p2 +
  seg_c1_p2@label(label = distance(seg_c1_p2)) +
  seg_c1_p2@midpoint(c(0,1)) +
  seg_c1_p2@midpoint(c(0))@label(
    label = p_labels[2], 
    polar_just = polar(theta = seg_c1_p3@line@angle, 1.5)) +
  seg_c1_p3 +
  seg_c1_p3@label(label = distance(seg_c1_p3)) + 
  seg_c1_p3@midpoint(c(0,1)) +
  seg_c1_p3@midpoint(c(0))@label(
    label = p_labels[3], 
    polar_just = polar(theta = seg_c1_p3@line@angle, 1.5))

  


```



# Convert points to geoms

The `as.geom` function is called implicitly whenever a point object is added to a ggplot.

```{r}
pts <- point(x = c(3,2), 
             y = c(4,3), 
             color = c("red", "blue"),
             size = c(3, 6))


ggplot() + 
  pts
```

This is equivalent to 

```{r}
ggplot() +
  as.geom(pts)
```

And this is equivalent to 

```{r}
ggplot() +
  geom_point(
    aes(
      x,
      y,
      color = I(color),
      size = I(size)), 
    data = get_tibble_defaults(pts))
```

That is, any style information that can be mapped will be handled via the `I` (identity) function in the mapping statement (`aes`).

Calling the `as.geom` function directly is useful for overriding any style information in the points. 

```{r}
ggplot() + 
  as.geom(pts, 
          stroke = 1.5,
          fill = "yellow", 
          shape = "triangle filled")
```

This is equivalent to 

```{r}
ggplot() +
  geom_point(
    aes(x = x, 
        y = y, 
        size = I(size), 
        color = I(color)),
    stroke = 1.5,
    fill = "yellow",
    shape = "triangle filled",
    data = get_tibble_defaults(pts)
  )
```









